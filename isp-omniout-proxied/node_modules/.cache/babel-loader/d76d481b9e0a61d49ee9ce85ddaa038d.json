{"ast":null,"code":"/*global process*/\n\n/**\n * @file Manages query for records in Salesforce\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n'use strict';\n\nvar inherits = require('inherits'),\n    events = require('events'),\n    stream = require('readable-stream'),\n    _ = require('lodash/core'),\n    Promise = require('./promise'),\n    SfDate = require(\"./date\"),\n    SOQLBuilder = require(\"./soql-builder\"),\n    RecordStream = require(\"./record-stream\");\n/**\n * Query\n *\n * @protected\n * @class\n * @extends {stream.Readable}\n * @implements Promise.<T>\n * @template T\n * @param {Connection} conn - Connection object\n * @param {Object|String} config - Query config object or SOQL string\n * @param {Object} [options] - Default query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n */\n\n\nvar Query = module.exports = function (conn, config, options) {\n  Query.super_.call(this, {\n    objectMode: true\n  });\n  this._conn = conn;\n\n  if (_.isString(config)) {\n    // if query config is string, it is given in SOQL.\n    this._soql = config;\n  } else if (config.locator && config.locator.indexOf(\"/\") >= 0) {\n    // if locator given in url for next records\n    this._locator = config.locator.split(\"/\").pop();\n  } else {\n    this._config = config;\n    this.select(config.fields);\n\n    if (config.includes) {\n      this.include(config.includes);\n    }\n\n    if (config.sort) {\n      this.sort(config.sort);\n    }\n  }\n\n  this._options = _.defaults(options || {}, {\n    maxFetch: 10000,\n    autoFetch: false,\n    scanAll: false,\n    responseTarget: ResponseTargets.QueryResult\n  });\n  this._executed = false;\n  this._finished = false;\n  this._chaining = false;\n  this._deferred = Promise.defer();\n  var self = this;\n};\n\ninherits(Query, stream.Readable);\n/**\n * Select fields to include in the returning result\n *\n * @param {Object|Array.<String>|String} fields - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @returns {Query.<T>}\n */\n\nQuery.prototype.select = function (fields) {\n  if (this._soql) {\n    throw Error(\"Cannot set select fields for the query which has already built SOQL.\");\n  }\n\n  fields = fields || '*';\n\n  if (_.isString(fields)) {\n    fields = fields.split(/\\s*,\\s*/);\n  } else if (_.isObject(fields) && !_.isArray(fields)) {\n    var _fields = [];\n\n    for (var k in fields) {\n      if (fields[k]) {\n        _fields.push(k);\n      }\n    }\n\n    fields = _fields;\n  }\n\n  this._config.fields = fields;\n  return this;\n};\n/**\n * Set query conditions to filter the result records\n *\n * @param {Object|String} conditions - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.where = function (conditions) {\n  if (this._soql) {\n    throw Error(\"Cannot set where conditions for the query which has already built SOQL.\");\n  }\n\n  this._config.conditions = conditions;\n  return this;\n};\n/**\n * Limit the returning result\n *\n * @param {Number} limit - Maximum number of records the query will return.\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.limit = function (limit) {\n  if (this._soql) {\n    throw Error(\"Cannot set limit for the query which has already built SOQL.\");\n  }\n\n  this._config.limit = limit;\n  return this;\n};\n/**\n * Synonym of Query#offset()\n *\n * @method Query#skip\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\n\n/**\n * Skip records\n *\n * @method Query#offset\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.skip = Query.prototype.offset = function (offset) {\n  if (this._soql) {\n    throw Error(\"Cannot set skip/offset for the query which has already built SOQL.\");\n  }\n\n  this._config.offset = offset;\n  return this;\n};\n/**\n * Synonym of Query#sort()\n *\n * @memthod Query#orderby\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\n\n/**\n * Set query sort with direction\n *\n * @method Query#sort\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.sort = Query.prototype.orderby = function (sort, dir) {\n  if (this._soql) {\n    throw Error(\"Cannot set sort for the query which has already built SOQL.\");\n  }\n\n  if (_.isString(sort) && _.isString(dir)) {\n    sort = [[sort, dir]];\n  }\n\n  this._config.sort = sort;\n  return this;\n};\n/**\n * Include child relationship query\n *\n * @param {String} childRelName - Child relationship name to include in query result\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Optional query configulations.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @returns {Query~SubQuery}\n */\n\n\nQuery.prototype.include = function (childRelName, conditions, fields, options) {\n  if (this._soql) {\n    throw Error(\"Cannot include child relationship into the query which has already built SOQL.\");\n  }\n\n  if (_.isObject(childRelName)) {\n    var includes = childRelName;\n\n    for (var crname in includes) {\n      var config = includes[crname];\n      this.include(crname, config.conditions, config.fields, config);\n    }\n\n    return;\n  }\n\n  var childConfig = {\n    table: childRelName,\n    conditions: conditions,\n    fields: fields,\n    limit: options && options.limit,\n    offset: options && (options.offset || options.skip),\n    sort: options && options.sort\n  };\n  if (!_.isArray(this._config.includes)) this._config.includes = [];\n\n  this._config.includes.push(childConfig);\n\n  var childQuery = new SubQuery(this._conn, this, childConfig);\n  this._children = this._children || [];\n\n  this._children.push(childQuery);\n\n  return childQuery;\n};\n/**\n * Setting maxFetch query option\n *\n * @param {Number} maxFetch - Max fetching records in auto fetch mode\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.maxFetch = function (maxFetch) {\n  this._options.maxFetch = maxFetch;\n  return this;\n};\n/**\n * Switching auto fetch mode\n *\n * @param {Boolean} autoFetch - Using auto fetch mode or not\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.autoFetch = function (autoFetch) {\n  this._options.autoFetch = autoFetch;\n  return this;\n};\n/**\n * Set flag to scan all records including deleted and archived.\n *\n * @param {Boolean} scanAll - Flag whether include deleted/archived record or not. Default is false.\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.scanAll = function (scanAll) {\n  this._options.scanAll = scanAll;\n  return this;\n};\n/**\n * @private\n */\n\n\nvar ResponseTargets = Query.ResponseTargets = {};\n[\"QueryResult\", \"Records\", \"SingleRecord\", \"Count\"].forEach(function (f) {\n  ResponseTargets[f] = f;\n});\n/**\n * @protected\n * @param {String} responseTarget - Query response target\n * @returns {Query.<S>}\n */\n\nQuery.prototype.setResponseTarget = function (responseTarget) {\n  if (responseTarget in ResponseTargets) {\n    this._options.responseTarget = responseTarget;\n  }\n\n  return this;\n};\n/**\n * Synonym of Query#execute()\n *\n * @method Query#run\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\n\n\nQuery.prototype.run =\n/**\n * Synonym of Query#execute()\n *\n * @method Query#exec\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.exec =\n/**\n * Execute query and fetch records from server.\n *\n * @method Query#execute\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.execute = function (options, callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  var deferred = this._deferred;\n\n  if (this._executed) {\n    deferred.reject(new Error(\"re-executing already executed query\"));\n    return this;\n  }\n\n  if (this._finished) {\n    deferred.reject(new Error(\"executing already closed query\"));\n    return this;\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options = {\n    headers: options.headers || self._options.headers,\n    responseTarget: options.responseTarget || self._options.responseTarget,\n    autoFetch: options.autoFetch || self._options.autoFetch,\n    maxFetch: options.maxFetch || self._options.maxFetch,\n    scanAll: options.scanAll || self._options.scanAll\n  }; // callback and promise resolution;\n\n  var promiseCallback = function (err, res) {\n    if (_.isFunction(callback)) {\n      try {\n        res = callback(err, res);\n        err = null;\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      deferred.reject(err);\n    } else {\n      deferred.resolve(res);\n    }\n  };\n\n  this.once('response', function (res) {\n    promiseCallback(null, res);\n  });\n  this.once('error', function (err) {\n    promiseCallback(err);\n  }); // collect fetched records in array\n  // only when response target is Records and\n  // either callback or chaining promises are available to this query.\n\n  this.once('fetch', function () {\n    if (options.responseTarget === ResponseTargets.Records && (self._chaining || callback)) {\n      logger.debug('--- collecting all fetched records ---');\n      var records = [];\n\n      var onRecord = function (record) {\n        records.push(record);\n      };\n\n      self.on('record', onRecord);\n      self.once('end', function () {\n        self.removeListener('record', onRecord);\n        self.emit('response', records, self);\n      });\n    }\n  }); // flag to prevent re-execution\n\n  this._executed = true; // start actual query\n\n  logger.debug('>>> Query start >>>');\n\n  this._execute(options).then(function () {\n    logger.debug('*** Query finished ***');\n  }).fail(function (err) {\n    logger.debug('--- Query error ---');\n    self.emit('error', err);\n  }); // return Query instance for chaining\n\n\n  return this;\n};\n/**\n * @private\n */\n\n\nQuery.prototype._execute = function (options) {\n  var self = this;\n  var logger = this._conn._logger;\n  var responseTarget = options.responseTarget;\n  var autoFetch = options.autoFetch;\n  var maxFetch = options.maxFetch;\n  var scanAll = options.scanAll;\n  return Promise.resolve(self._locator ? self._conn._baseUrl() + \"/query/\" + self._locator : self.toSOQL().then(function (soql) {\n    self.totalFetched = 0;\n    logger.debug(\"SOQL = \" + soql);\n    return self._conn._baseUrl() + \"/\" + (scanAll ? \"queryAll\" : \"query\") + \"?q=\" + encodeURIComponent(soql);\n  })).then(function (url) {\n    return self._conn.request({\n      method: 'GET',\n      url: url,\n      headers: options.headers\n    });\n  }).then(function (data) {\n    self.emit(\"fetch\");\n    self.totalSize = data.totalSize;\n    var res;\n\n    switch (responseTarget) {\n      case ResponseTargets.SingleRecord:\n        res = data.records && data.records.length > 0 ? data.records[0] : null;\n        break;\n\n      case ResponseTargets.Records:\n        res = data.records;\n        break;\n\n      case ResponseTargets.Count:\n        res = data.totalSize;\n        break;\n\n      default:\n        res = data;\n    } // only fire response event when it should be notified per fetch\n\n\n    if (responseTarget !== ResponseTargets.Records) {\n      self.emit(\"response\", res, self);\n    } // streaming record instances\n\n\n    var numRecords = data.records && data.records.length || 0;\n\n    for (var i = 0; i < numRecords; i++) {\n      if (self.totalFetched >= maxFetch) {\n        self._finished = true;\n        break;\n      }\n\n      var record = data.records[i];\n      self.push(record);\n      self.emit('record', record, self.totalFetched++, self);\n    }\n\n    if (data.nextRecordsUrl) {\n      self._locator = data.nextRecordsUrl.split('/').pop();\n    }\n\n    self._finished = self._finished || data.done || !autoFetch;\n\n    if (self._finished) {\n      self.push(null);\n    } else {\n      self._execute(options);\n    }\n\n    return res;\n  });\n};\n/**\n * Readable stream implementation\n *\n * @override\n * @private\n */\n\n\nQuery.prototype._read = function (size) {\n  if (!this._finished && !this._executed) {\n    this.execute({\n      autoFetch: true\n    });\n  }\n};\n/** @override **/\n\n\nQuery.prototype.on = function (e, fn) {\n  if (e === 'record') {\n    var self = this;\n    this.on('readable', function () {\n      while (self.read() !== null) {} // discard buffered records\n\n    });\n  }\n\n  return Query.super_.prototype.on.call(this, e, fn);\n};\n/** @override **/\n\n\nQuery.prototype.addListener = Query.prototype.on;\n/**\n * @private\n */\n\nQuery.prototype._expandFields = function () {\n  if (this._soql) {\n    return Promise.reject(new Error(\"Cannot expand fields for the query which has already built SOQL.\"));\n  }\n\n  var self = this;\n  var logger = self._conn._logger;\n  var conn = this._conn;\n  var table = this._config.table;\n  var fields = this._config.fields || [];\n  logger.debug('_expandFields: table = ' + table + ', fields = ' + fields.join(', '));\n  return Promise.all([Promise.resolve(self._parent ? findRelationTable(table) : table).then(function (table) {\n    return Promise.all(_.map(fields, function (field) {\n      return expandAsteriskField(table, field);\n    })).then(function (expandedFields) {\n      self._config.fields = _.flatten(expandedFields);\n    });\n  }), Promise.all(_.map(self._children || [], function (childQuery) {\n    return childQuery._expandFields();\n  }))]);\n\n  function findRelationTable(rname) {\n    var ptable = self._parent._config.table;\n    logger.debug('finding table for relation \"' + rname + '\" in \"' + ptable + '\"...');\n    return describeCache(ptable).then(function (sobject) {\n      var upperRname = rname.toUpperCase();\n\n      var childRelation = _.find(sobject.childRelationships, function (cr) {\n        return (cr.relationshipName || '').toUpperCase() === upperRname;\n      });\n\n      return childRelation ? childRelation.childSObject : Promise.reject(new Error(\"No child relationship found: \" + rname));\n    });\n  }\n\n  function describeCache(table) {\n    logger.debug('describe cache: ' + table);\n    var deferred = Promise.defer();\n    conn.describe$(table, function (err, sobject) {\n      logger.debug('... done.');\n\n      if (err) {\n        deferred.reject(err);\n      } else {\n        deferred.resolve(sobject);\n      }\n    });\n    return deferred.promise;\n  }\n\n  function expandAsteriskField(table, field) {\n    logger.debug('expanding field \"' + field + '\" in \"' + table + '\"...');\n    var fpath = field.split('.');\n    return fpath[fpath.length - 1] === '*' ? describeCache(table).then(function (sobject) {\n      logger.debug('table ' + table + 'has been described');\n\n      if (fpath.length > 1) {\n        var rname = fpath.shift();\n\n        var rfield = _.find(sobject.fields, function (f) {\n          return f.relationshipName && f.relationshipName.toUpperCase() === rname.toUpperCase();\n        });\n\n        if (rfield) {\n          var rtable = rfield.referenceTo.length === 1 ? rfield.referenceTo[0] : 'Name';\n          return expandAsteriskField(rtable, fpath.join('.')).then(function (fpaths) {\n            return _.map(fpaths, function (fpath) {\n              return rname + '.' + fpath;\n            });\n          });\n        } else {\n          return [];\n        }\n      } else {\n        return _.map(sobject.fields, function (f) {\n          return f.name;\n        });\n      }\n    }) : Promise.resolve([field]);\n  }\n};\n/**\n * Explain plan for executing query\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\n\n\nQuery.prototype.explain = function (callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  return self.toSOQL().then(function (soql) {\n    logger.debug(\"SOQL = \" + soql);\n    var url = \"/query/?explain=\" + encodeURIComponent(soql);\n    return self._conn.request(url);\n  }).thenCall(callback);\n};\n/**\n * Return SOQL expression for the query\n *\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\n\n\nQuery.prototype.toSOQL = function (callback) {\n  var self = this;\n  return Promise.resolve(self._soql || self._expandFields().then(function () {\n    return SOQLBuilder.createSOQL(self._config);\n  })).thenCall(callback);\n};\n/**\n * Create data stream of queried records.\n * Automatically resume query if paused.\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n */\n\n\nQuery.prototype.stream = RecordStream.Serializable.prototype.stream;\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\n\nQuery.prototype.map = RecordStream.prototype.map;\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\n\nQuery.prototype.filter = RecordStream.prototype.map;\n/*\n * Default threshold num of bulk API switching\n */\n\nvar DEFAULT_BULK_THRESHOLD = 200;\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#delete\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#del\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n\n/**\n * Delete queried records\n *\n * @method Query#destroy\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass delete operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n\nQuery.prototype[\"delete\"] = Query.prototype.del = Query.prototype.destroy = function (type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n\n  options = options || {};\n  type = type || this._config && this._config.table;\n\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk delete.\");\n  } // Set the threshold number to pass to bulk API\n\n\n  var thresholdNum = options.allowBulk === false ? -1 : typeof options.bulkThreshold === 'number' ? options.bulkThreshold : // determine threshold if the connection version supports SObject collection API or not\n  this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2;\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var records = [];\n    var batch = null;\n\n    var handleRecord = function (rec) {\n      if (!rec.Id) {\n        self.emit('error', new Error('Queried record does not include Salesforce record ID.'));\n        return;\n      }\n\n      var record = {\n        Id: rec.Id\n      };\n\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk delete instead of SObject REST API\n          batch = self._conn.sobject(type).deleteBulk().on('response', resolve).on('error', reject);\n          records.forEach(function (record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n\n    var handleEnd = function () {\n      if (batch) {\n        batch.end();\n      } else {\n        var ids = records.map(function (record) {\n          return record.Id;\n        });\n\n        self._conn.sobject(type).destroy(ids, {\n          allowRecursive: true\n        }).then(resolve, reject);\n      }\n    };\n\n    self.on('data', handleRecord).on('end', handleEnd).on('error', reject);\n  }).thenCall(callback);\n};\n/**\n * Update queried records, using given mapping function/object\n *\n * @param {Record|RecordMapFunction} mapping - Mapping record or record mapping function\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass update operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n\n\nQuery.prototype.update = function (mapping, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n\n  options = options || {};\n  type = type || this._config && this._config.table;\n\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk update.\");\n  }\n\n  var updateStream = _.isFunction(mapping) ? RecordStream.map(mapping) : RecordStream.recordMapStream(mapping); // Set the threshold number to pass to bulk API\n\n  var thresholdNum = options.allowBulk === false ? -1 : typeof options.bulkThreshold === 'number' ? options.bulkThreshold : // determine threshold if the connection version supports SObject collection API or not\n  this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2;\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var records = [];\n    var batch = null;\n\n    var handleRecord = function (record) {\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk update instead of SObject REST API\n          batch = self._conn.sobject(type).updateBulk().on('response', resolve).on('error', reject);\n          records.forEach(function (record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n\n    var handleEnd = function () {\n      if (batch) {\n        batch.end();\n      } else {\n        self._conn.sobject(type).update(records, {\n          allowRecursive: true\n        }).then(resolve, reject);\n      }\n    };\n\n    self.on('error', reject).pipe(updateStream).on('data', handleRecord).on('end', handleEnd).on('error', reject);\n  }).thenCall(callback);\n};\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for query result\n *\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\n\n\nQuery.prototype.then = function (onResolved, onReject) {\n  this._chaining = true;\n\n  if (!this._finished && !this._executed) {\n    this.execute();\n  }\n\n  return this._deferred.promise.then.apply(this._deferred.promise, arguments);\n};\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query}\n */\n\n\nQuery.prototype.thenCall = function (callback) {\n  if (_.isFunction(callback)) {\n    this.then(function (res) {\n      process.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (err) {\n      process.nextTick(function () {\n        callback(err);\n      });\n    });\n  }\n\n  return this;\n};\n/*--------------------------------------------*/\n\n/**\n * SubQuery object for representing child relationship query\n *\n * @protected\n * @class Query~SubQuery\n * @extends Query\n * @param {Connection} conn - Connection object\n * @param {Query} parent - Parent query object\n * @param {Object} config - Sub query configuration\n */\n\n\nvar SubQuery = function (conn, parent, config) {\n  SubQuery.super_.call(this, conn, config);\n  this._parent = parent;\n};\n\ninherits(SubQuery, Query);\n/**\n * @method Query~SubQuery#include\n * @override\n */\n\nSubQuery.prototype.include = function () {\n  throw new Error(\"Not allowed to include another subquery in subquery.\");\n};\n/**\n * Back the context to parent query object\n *\n * @method Query~SubQuery#end\n * @returns {Query}\n */\n\n\nSubQuery.prototype.end = function () {\n  return this._parent;\n};\n/**\n * If execute is called in subquery context, delegate it to parent query object\n *\n * @method Query~SubQuery#execute\n * @override\n */\n\n\nSubQuery.prototype.run = SubQuery.prototype.exec = SubQuery.prototype.execute = function () {\n  return this._parent.execute.apply(this._parent, arguments);\n};","map":{"version":3,"sources":["/Users/gcarminati/Desktop/OmniStudio/OmniProxy/react-express-proxy-sample/node_modules/jsforce/lib/query.js"],"names":["inherits","require","events","stream","_","Promise","SfDate","SOQLBuilder","RecordStream","Query","module","exports","conn","config","options","super_","call","objectMode","_conn","isString","_soql","locator","indexOf","_locator","split","pop","_config","select","fields","includes","include","sort","_options","defaults","maxFetch","autoFetch","scanAll","responseTarget","ResponseTargets","QueryResult","_executed","_finished","_chaining","_deferred","defer","self","Readable","prototype","Error","isObject","isArray","_fields","k","push","where","conditions","limit","skip","offset","orderby","dir","childRelName","crname","childConfig","table","childQuery","SubQuery","_children","forEach","f","setResponseTarget","run","exec","execute","callback","logger","_logger","deferred","reject","headers","promiseCallback","err","res","isFunction","e","resolve","once","Records","debug","records","onRecord","record","on","removeListener","emit","_execute","then","fail","_baseUrl","toSOQL","soql","totalFetched","encodeURIComponent","url","request","method","data","totalSize","SingleRecord","length","Count","numRecords","i","nextRecordsUrl","done","_read","size","fn","read","addListener","_expandFields","join","all","_parent","findRelationTable","map","field","expandAsteriskField","expandedFields","flatten","rname","ptable","describeCache","sobject","upperRname","toUpperCase","childRelation","find","childRelationships","cr","relationshipName","childSObject","describe$","promise","fpath","shift","rfield","rtable","referenceTo","fpaths","name","explain","thenCall","createSOQL","Serializable","filter","DEFAULT_BULK_THRESHOLD","del","destroy","type","thresholdNum","allowBulk","bulkThreshold","_ensureVersion","maxRequest","batch","handleRecord","rec","Id","write","deleteBulk","handleEnd","end","ids","allowRecursive","update","mapping","updateStream","recordMapStream","updateBulk","pipe","onResolved","onReject","apply","arguments","process","nextTick","parent"],"mappings":"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","sourcesContent":["/*global process*/\n/**\n * @file Manages query for records in Salesforce\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar inherits = require('inherits'),\n    events = require('events'),\n    stream = require('readable-stream'),\n    _      = require('lodash/core'),\n    Promise = require('./promise'),\n    SfDate = require(\"./date\"),\n    SOQLBuilder = require(\"./soql-builder\"),\n    RecordStream = require(\"./record-stream\");\n\n/**\n * Query\n *\n * @protected\n * @class\n * @extends {stream.Readable}\n * @implements Promise.<T>\n * @template T\n * @param {Connection} conn - Connection object\n * @param {Object|String} config - Query config object or SOQL string\n * @param {Object} [options] - Default query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n */\nvar Query = module.exports = function(conn, config, options) {\n  Query.super_.call(this, { objectMode: true });\n\n  this._conn = conn;\n  if (_.isString(config)) { // if query config is string, it is given in SOQL.\n    this._soql = config;\n  } else if (config.locator && config.locator.indexOf(\"/\") >= 0) { // if locator given in url for next records\n    this._locator = config.locator.split(\"/\").pop();\n  } else {\n    this._config = config;\n    this.select(config.fields);\n    if (config.includes) {\n      this.include(config.includes);\n    }\n    if (config.sort) {\n      this.sort(config.sort);\n    }\n  }\n  this._options = _.defaults(options || {}, {\n    maxFetch: 10000,\n    autoFetch: false,\n    scanAll: false,\n    responseTarget: ResponseTargets.QueryResult\n  });\n  this._executed = false;\n  this._finished = false;\n  this._chaining = false;\n\n  this._deferred = Promise.defer();\n\n  var self = this;\n};\n\ninherits(Query, stream.Readable);\n\n/**\n * Select fields to include in the returning result\n *\n * @param {Object|Array.<String>|String} fields - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @returns {Query.<T>}\n */\nQuery.prototype.select = function(fields) {\n  if (this._soql) {\n    throw Error(\"Cannot set select fields for the query which has already built SOQL.\");\n  }\n  fields = fields || '*';\n  if (_.isString(fields)) {\n    fields = fields.split(/\\s*,\\s*/);\n  } else if (_.isObject(fields) && !_.isArray(fields)) {\n    var _fields =  [];\n    for (var k in fields) {\n      if (fields[k]) { _fields.push(k); }\n    }\n    fields = _fields;\n  }\n  this._config.fields = fields;\n  return this;\n};\n\n/**\n * Set query conditions to filter the result records\n *\n * @param {Object|String} conditions - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @returns {Query.<T>}\n */\nQuery.prototype.where = function(conditions) {\n  if (this._soql) {\n    throw Error(\"Cannot set where conditions for the query which has already built SOQL.\");\n  }\n  this._config.conditions = conditions;\n  return this;\n};\n\n/**\n * Limit the returning result\n *\n * @param {Number} limit - Maximum number of records the query will return.\n * @returns {Query.<T>}\n */\nQuery.prototype.limit = function(limit) {\n  if (this._soql) {\n    throw Error(\"Cannot set limit for the query which has already built SOQL.\");\n  }\n  this._config.limit = limit;\n  return this;\n};\n\n/**\n * Synonym of Query#offset()\n *\n * @method Query#skip\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\n/**\n * Skip records\n *\n * @method Query#offset\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\nQuery.prototype.skip =\nQuery.prototype.offset = function(offset) {\n  if (this._soql) {\n    throw Error(\"Cannot set skip/offset for the query which has already built SOQL.\");\n  }\n  this._config.offset = offset;\n  return this;\n};\n\n/**\n * Synonym of Query#sort()\n *\n * @memthod Query#orderby\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\n/**\n * Set query sort with direction\n *\n * @method Query#sort\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\nQuery.prototype.sort =\nQuery.prototype.orderby = function(sort, dir) {\n  if (this._soql) {\n    throw Error(\"Cannot set sort for the query which has already built SOQL.\");\n  }\n  if (_.isString(sort) && _.isString(dir)) {\n    sort = [ [ sort, dir ] ];\n  }\n  this._config.sort = sort;\n  return this;\n};\n\n/**\n * Include child relationship query\n *\n * @param {String} childRelName - Child relationship name to include in query result\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Optional query configulations.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @returns {Query~SubQuery}\n */\nQuery.prototype.include = function(childRelName, conditions, fields, options) {\n  if (this._soql) {\n    throw Error(\"Cannot include child relationship into the query which has already built SOQL.\");\n  }\n  if (_.isObject(childRelName)) {\n    var includes = childRelName;\n    for (var crname in includes) {\n      var config = includes[crname];\n      this.include(crname, config.conditions, config.fields, config);\n    }\n    return;\n  }\n  var childConfig = {\n    table: childRelName,\n    conditions: conditions,\n    fields: fields,\n    limit: options && options.limit,\n    offset: options && (options.offset || options.skip),\n    sort: options && options.sort\n  };\n  if (!_.isArray(this._config.includes)) this._config.includes = [];\n  this._config.includes.push(childConfig);\n  var childQuery = new SubQuery(this._conn, this, childConfig);\n  this._children = this._children || [];\n  this._children.push(childQuery);\n  return childQuery;\n};\n\n\n/**\n * Setting maxFetch query option\n *\n * @param {Number} maxFetch - Max fetching records in auto fetch mode\n * @returns {Query.<T>}\n */\nQuery.prototype.maxFetch = function(maxFetch) {\n  this._options.maxFetch = maxFetch;\n  return this;\n};\n\n/**\n * Switching auto fetch mode\n *\n * @param {Boolean} autoFetch - Using auto fetch mode or not\n * @returns {Query.<T>}\n */\nQuery.prototype.autoFetch = function(autoFetch) {\n  this._options.autoFetch = autoFetch;\n  return this;\n};\n\n/**\n * Set flag to scan all records including deleted and archived.\n *\n * @param {Boolean} scanAll - Flag whether include deleted/archived record or not. Default is false.\n * @returns {Query.<T>}\n */\nQuery.prototype.scanAll = function(scanAll) {\n  this._options.scanAll = scanAll;\n  return this;\n};\n\n/**\n * @private\n */\nvar ResponseTargets = Query.ResponseTargets = {};\n[ \"QueryResult\", \"Records\", \"SingleRecord\", \"Count\" ].forEach(function(f) {\n  ResponseTargets[f] = f;\n});\n\n/**\n * @protected\n * @param {String} responseTarget - Query response target\n * @returns {Query.<S>}\n */\nQuery.prototype.setResponseTarget = function(responseTarget) {\n  if (responseTarget in ResponseTargets) {\n    this._options.responseTarget = responseTarget;\n  }\n  return this;\n};\n\n\n/**\n * Synonym of Query#execute()\n *\n * @method Query#run\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.run =\n/**\n * Synonym of Query#execute()\n *\n * @method Query#exec\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.exec =\n/**\n * Execute query and fetch records from server.\n *\n * @method Query#execute\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.execute = function(options, callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  var deferred = this._deferred;\n\n  if (this._executed) {\n    deferred.reject(new Error(\"re-executing already executed query\"));\n    return this;\n  }\n\n  if (this._finished) {\n    deferred.reject(new Error(\"executing already closed query\"));\n    return this;\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options = {\n    headers: options.headers || self._options.headers,\n    responseTarget: options.responseTarget || self._options.responseTarget,\n    autoFetch: options.autoFetch || self._options.autoFetch,\n    maxFetch: options.maxFetch || self._options.maxFetch,\n    scanAll: options.scanAll || self._options.scanAll\n  };\n\n  // callback and promise resolution;\n  var promiseCallback = function(err, res) {\n    if (_.isFunction(callback)) {\n      try {\n        res = callback(err, res);\n        err = null;\n      } catch(e) {\n        err = e;\n      }\n    }\n    if (err) {\n      deferred.reject(err);\n    } else {\n      deferred.resolve(res);\n    }\n  };\n  this.once('response', function(res) {\n    promiseCallback(null, res);\n  });\n  this.once('error', function(err) {\n    promiseCallback(err);\n  });\n\n  // collect fetched records in array\n  // only when response target is Records and\n  // either callback or chaining promises are available to this query.\n  this.once('fetch', function() {\n    if (options.responseTarget === ResponseTargets.Records && (self._chaining || callback)) {\n      logger.debug('--- collecting all fetched records ---');\n      var records = [];\n      var onRecord = function(record) {\n        records.push(record);\n      };\n      self.on('record', onRecord);\n      self.once('end', function() {\n        self.removeListener('record', onRecord);\n        self.emit('response', records, self);\n      });\n    }\n  });\n\n  // flag to prevent re-execution\n  this._executed = true;\n\n  // start actual query\n  logger.debug('>>> Query start >>>');\n  this._execute(options).then(function() {\n    logger.debug('*** Query finished ***');\n  }).fail(function(err) {\n    logger.debug('--- Query error ---');\n    self.emit('error', err);\n  });\n\n  // return Query instance for chaining\n  return this;\n};\n\n/**\n * @private\n */\nQuery.prototype._execute = function(options) {\n  var self = this;\n  var logger = this._conn._logger;\n  var responseTarget = options.responseTarget;\n  var autoFetch = options.autoFetch;\n  var maxFetch = options.maxFetch;\n  var scanAll = options.scanAll;\n\n  return Promise.resolve(\n    self._locator ?\n    self._conn._baseUrl() + \"/query/\" + self._locator :\n    self.toSOQL().then(function(soql) {\n      self.totalFetched = 0;\n      logger.debug(\"SOQL = \" + soql);\n      return self._conn._baseUrl() + \"/\" + (scanAll ? \"queryAll\" : \"query\") + \"?q=\" + encodeURIComponent(soql);\n    })\n  ).then(function(url) {\n    return self._conn.request({\n      method: 'GET',\n      url: url,\n      headers: options.headers\n    });\n  }).then(function(data) {\n    self.emit(\"fetch\");\n    self.totalSize = data.totalSize;\n    var res;\n    switch(responseTarget) {\n      case ResponseTargets.SingleRecord:\n        res = data.records && data.records.length > 0 ? data.records[0] : null;\n        break;\n      case ResponseTargets.Records:\n        res = data.records;\n        break;\n      case ResponseTargets.Count:\n        res = data.totalSize;\n        break;\n      default:\n        res = data;\n    }\n    // only fire response event when it should be notified per fetch\n    if (responseTarget !== ResponseTargets.Records) {\n      self.emit(\"response\", res, self);\n    }\n\n    // streaming record instances\n    var numRecords = (data.records && data.records.length) || 0;\n    for (var i=0; i<numRecords; i++) {\n      if (self.totalFetched >= maxFetch) {\n        self._finished = true;\n        break;\n      }\n      var record = data.records[i];\n      self.push(record);\n      self.emit('record', record, self.totalFetched++, self);\n    }\n    if (data.nextRecordsUrl) {\n      self._locator = data.nextRecordsUrl.split('/').pop();\n    }\n    self._finished = self._finished || data.done || !autoFetch;\n    if (self._finished) {\n      self.push(null);\n    } else {\n      self._execute(options);\n    }\n    return res;\n  });\n};\n\n/**\n * Readable stream implementation\n *\n * @override\n * @private\n */\nQuery.prototype._read = function(size) {\n  if (!this._finished && !this._executed) {\n    this.execute({ autoFetch: true });\n  }\n};\n\n/** @override **/\nQuery.prototype.on = function(e, fn) {\n  if (e === 'record') {\n    var self = this;\n    this.on('readable', function() {\n      while(self.read() !== null) {} // discard buffered records\n    });\n  }\n  return Query.super_.prototype.on.call(this, e, fn);\n};\n\n/** @override **/\nQuery.prototype.addListener = Query.prototype.on;\n\n\n/**\n * @private\n */\nQuery.prototype._expandFields = function() {\n  if (this._soql) {\n    return Promise.reject(new Error(\"Cannot expand fields for the query which has already built SOQL.\"));\n  }\n  var self = this;\n  var logger = self._conn._logger;\n  var conn = this._conn;\n  var table = this._config.table;\n  var fields = this._config.fields || [];\n\n  logger.debug('_expandFields: table = ' + table + ', fields = ' + fields.join(', '));\n\n  return Promise.all([\n    Promise.resolve(self._parent ? findRelationTable(table) : table)\n      .then(function(table) {\n        return Promise.all(\n          _.map(fields, function(field) { return expandAsteriskField(table, field); })\n        ).then(function(expandedFields) {\n          self._config.fields = _.flatten(expandedFields);\n        });\n      }),\n    Promise.all(\n      _.map(self._children || [], function(childQuery) {\n        return childQuery._expandFields();\n      })\n    )\n  ]);\n\n  function findRelationTable(rname) {\n    var ptable = self._parent._config.table;\n    logger.debug('finding table for relation \"' + rname + '\" in \"' + ptable + '\"...');\n    return describeCache(ptable).then(function(sobject) {\n      var upperRname = rname.toUpperCase();\n      var childRelation = _.find(sobject.childRelationships, function(cr) {\n        return (cr.relationshipName || '').toUpperCase() === upperRname;\n      });\n      return childRelation ? childRelation.childSObject :\n        Promise.reject(new Error(\"No child relationship found: \" + rname ));\n    });\n  }\n\n  function describeCache(table) {\n    logger.debug('describe cache: '+table);\n    var deferred = Promise.defer();\n    conn.describe$(table, function(err, sobject) {\n      logger.debug('... done.');\n      if (err) { deferred.reject(err); }\n      else { deferred.resolve(sobject); }\n    });\n    return deferred.promise;\n  }\n\n  function expandAsteriskField(table, field) {\n    logger.debug('expanding field \"'+ field + '\" in \"' + table + '\"...');\n    var fpath = field.split('.');\n    return fpath[fpath.length - 1] === '*' ?\n      describeCache(table).then(function(sobject) {\n        logger.debug('table '+table+'has been described');\n        if (fpath.length > 1) {\n          var rname = fpath.shift();\n          var rfield = _.find(sobject.fields, function(f) {\n            return f.relationshipName &&\n                   f.relationshipName.toUpperCase() === rname.toUpperCase();\n          });\n          if (rfield) {\n            var rtable = rfield.referenceTo.length === 1 ? rfield.referenceTo[0] : 'Name';\n            return expandAsteriskField(rtable, fpath.join('.')).then(function(fpaths) {\n              return _.map(fpaths, function(fpath) { return rname + '.' + fpath; });\n            });\n          } else {\n            return [];\n          }\n        } else {\n          return _.map(sobject.fields, function(f) { return f.name; });\n        }\n      }) :\n      Promise.resolve([ field ]);\n  }\n};\n\n/**\n * Explain plan for executing query\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nQuery.prototype.explain = function(callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  return self.toSOQL().then(function(soql) {\n    logger.debug(\"SOQL = \" + soql);\n    var url = \"/query/?explain=\" + encodeURIComponent(soql);\n    return self._conn.request(url);\n  }).thenCall(callback);\n};\n\n/**\n * Return SOQL expression for the query\n *\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\nQuery.prototype.toSOQL = function(callback) {\n  var self = this;\n  return Promise.resolve(self._soql ||\n    self._expandFields().then(function() { return SOQLBuilder.createSOQL(self._config); })\n  ).thenCall(callback);\n};\n\n/**\n * Create data stream of queried records.\n * Automatically resume query if paused.\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n */\nQuery.prototype.stream = RecordStream.Serializable.prototype.stream;\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.map = RecordStream.prototype.map;\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.filter = RecordStream.prototype.map;\n\n/*\n * Default threshold num of bulk API switching\n */\nvar DEFAULT_BULK_THRESHOLD = 200;\n\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#delete\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#del\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Delete queried records\n *\n * @method Query#destroy\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass delete operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype[\"delete\"] =\nQuery.prototype.del =\nQuery.prototype.destroy = function(type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk delete.\");\n  }\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(rec) {\n      if (!rec.Id) {\n        self.emit('error', new Error('Queried record does not include Salesforce record ID.'))\n        return;\n      }\n      var record = { Id: rec.Id };\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk delete instead of SObject REST API\n          batch =\n            self._conn.sobject(type).deleteBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        var ids = records.map(function (record) { return record.Id; });\n        self._conn.sobject(type).destroy(ids, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Update queried records, using given mapping function/object\n *\n * @param {Record|RecordMapFunction} mapping - Mapping record or record mapping function\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass update operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype.update = function(mapping, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk update.\");\n  }\n  var updateStream = _.isFunction(mapping) ? RecordStream.map(mapping) : RecordStream.recordMapStream(mapping);\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(record) {\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk update instead of SObject REST API\n          batch =\n            self._conn.sobject(type).updateBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        self._conn.sobject(type).update(records, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('error', reject)\n      .pipe(updateStream)\n      .on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for query result\n *\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\nQuery.prototype.then = function(onResolved, onReject) {\n  this._chaining = true;\n  if (!this._finished && !this._executed) { this.execute(); }\n  return this._deferred.promise.then.apply(this._deferred.promise, arguments);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query}\n */\nQuery.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * SubQuery object for representing child relationship query\n *\n * @protected\n * @class Query~SubQuery\n * @extends Query\n * @param {Connection} conn - Connection object\n * @param {Query} parent - Parent query object\n * @param {Object} config - Sub query configuration\n */\nvar SubQuery = function(conn, parent, config) {\n  SubQuery.super_.call(this, conn, config);\n  this._parent = parent;\n};\n\ninherits(SubQuery, Query);\n\n/**\n * @method Query~SubQuery#include\n * @override\n */\nSubQuery.prototype.include = function() {\n  throw new Error(\"Not allowed to include another subquery in subquery.\");\n};\n\n/**\n * Back the context to parent query object\n *\n * @method Query~SubQuery#end\n * @returns {Query}\n */\nSubQuery.prototype.end = function() {\n  return this._parent;\n};\n\n/**\n * If execute is called in subquery context, delegate it to parent query object\n *\n * @method Query~SubQuery#execute\n * @override\n */\nSubQuery.prototype.run =\nSubQuery.prototype.exec =\nSubQuery.prototype.execute = function() {\n  return this._parent.execute.apply(this._parent, arguments);\n};\n"]},"metadata":{},"sourceType":"script"}