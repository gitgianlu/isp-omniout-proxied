{"ast":null,"code":"/**\n * @file Manages asynchronous method response cache\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n'use strict';\n\nvar events = require('events'),\n    inherits = require('inherits'),\n    _ = require('lodash/core');\n/**\n * Class for managing cache entry\n *\n * @private\n * @class\n * @constructor\n * @template T\n */\n\n\nvar CacheEntry = function () {\n  this.fetching = false;\n};\n\ninherits(CacheEntry, events.EventEmitter);\n/**\n * Get value in the cache entry\n *\n * @param {Callback.<T>} [callback] - Callback function callbacked the cache entry updated\n * @returns {T|undefined}\n */\n\nCacheEntry.prototype.get = function (callback) {\n  if (!callback) {\n    return this._value;\n  } else {\n    this.once('value', callback);\n\n    if (!_.isUndefined(this._value)) {\n      this.emit('value', this._value);\n    }\n  }\n};\n/**\n * Set value in the cache entry\n *\n * @param {T} [value] - A value for caching\n */\n\n\nCacheEntry.prototype.set = function (value) {\n  this._value = value;\n  this.emit('value', this._value);\n};\n/**\n * Clear cached value\n */\n\n\nCacheEntry.prototype.clear = function () {\n  this.fetching = false;\n  delete this._value;\n};\n/**\n * Caching manager for async methods\n *\n * @class\n * @constructor\n */\n\n\nvar Cache = function () {\n  this._entries = {};\n};\n/**\n * retrive cache entry, or create if not exists.\n *\n * @param {String} [key] - Key of cache entry\n * @returns {CacheEntry}\n */\n\n\nCache.prototype.get = function (key) {\n  if (key && this._entries[key]) {\n    return this._entries[key];\n  } else {\n    var entry = new CacheEntry();\n    this._entries[key] = entry;\n    return entry;\n  }\n};\n/**\n * clear cache entries prefix matching given key\n * @param {String} [key] - Key prefix of cache entry to clear\n */\n\n\nCache.prototype.clear = function (key) {\n  for (var k in this._entries) {\n    if (!key || k.indexOf(key) === 0) {\n      this._entries[k].clear();\n    }\n  }\n};\n/**\n * create and return cache key from namespace and serialized arguments.\n * @private\n */\n\n\nfunction createCacheKey(namespace, args) {\n  args = Array.prototype.slice.apply(args);\n  return namespace + '(' + _.map(args, function (a) {\n    return JSON.stringify(a);\n  }).join(',') + ')';\n}\n/**\n * Enable caching for async call fn to intercept the response and store it to cache.\n * The original async calll fn is always invoked.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\n\n\nCache.prototype.makeResponseCacheable = function (fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  return function () {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n      callback = null;\n    }\n\n    var key = _.isString(options.key) ? options.key : _.isFunction(options.key) ? options.key.apply(scope, args) : createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n    entry.fetching = true;\n\n    if (callback) {\n      args.push(function (err, result) {\n        entry.set({\n          error: err,\n          result: result\n        });\n        callback(err, result);\n      });\n    }\n\n    var ret, error;\n\n    try {\n      ret = fn.apply(scope || this, args);\n    } catch (e) {\n      error = e;\n    }\n\n    if (ret && _.isFunction(ret.then)) {\n      // if the returned value is promise\n      if (!callback) {\n        return ret.then(function (result) {\n          entry.set({\n            error: undefined,\n            result: result\n          });\n          return result;\n        }, function (err) {\n          entry.set({\n            error: err,\n            result: undefined\n          });\n          throw err;\n        });\n      } else {\n        return ret;\n      }\n    } else {\n      entry.set({\n        error: error,\n        result: ret\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      return ret;\n    }\n  };\n};\n/**\n * Enable caching for async call fn to lookup the response cache first, then invoke original if no cached value.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\n\n\nCache.prototype.makeCacheable = function (fn, scope, options) {\n  var cache = this;\n  options = options || {};\n\n  var $fn = function () {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n    }\n\n    var key = _.isString(options.key) ? options.key : _.isFunction(options.key) ? options.key.apply(scope, args) : createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n\n    if (!_.isFunction(callback)) {\n      // if callback is not given in last arg, return cached result (immediate).\n      var value = entry.get();\n\n      if (!value) {\n        throw new Error('Function call result is not cached yet.');\n      }\n\n      if (value.error) {\n        throw value.error;\n      }\n\n      return value.result;\n    }\n\n    entry.get(function (value) {\n      callback(value.error, value.result);\n    });\n\n    if (!entry.fetching) {\n      // only when no other client is calling function\n      entry.fetching = true;\n      args.push(function (err, result) {\n        entry.set({\n          error: err,\n          result: result\n        });\n      });\n      fn.apply(scope || this, args);\n    }\n  };\n\n  $fn.clear = function () {\n    var key = _.isString(options.key) ? options.key : _.isFunction(options.key) ? options.key.apply(scope, arguments) : createCacheKey(options.namespace, arguments);\n    cache.clear(key);\n  };\n\n  return $fn;\n};\n\nmodule.exports = Cache;","map":{"version":3,"sources":["/Users/gcarminati/Desktop/OmniStudio/OmniProxy/react-express-proxy-sample/node_modules/jsforce/lib/cache.js"],"names":["events","require","inherits","_","CacheEntry","fetching","EventEmitter","prototype","get","callback","_value","once","isUndefined","emit","set","value","clear","Cache","_entries","key","entry","k","indexOf","createCacheKey","namespace","args","Array","slice","apply","map","a","JSON","stringify","join","makeResponseCacheable","fn","scope","options","cache","arguments","pop","isFunction","push","isString","err","result","error","ret","e","then","undefined","makeCacheable","$fn","Error","module","exports"],"mappings":"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","sourcesContent":["/**\n * @file Manages asynchronous method response cache\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar events = require('events'),\n    inherits = require('inherits'),\n    _      = require('lodash/core');\n\n/**\n * Class for managing cache entry\n *\n * @private\n * @class\n * @constructor\n * @template T\n */\nvar CacheEntry = function() {\n  this.fetching = false;\n};\n\ninherits(CacheEntry, events.EventEmitter);\n\n/**\n * Get value in the cache entry\n *\n * @param {Callback.<T>} [callback] - Callback function callbacked the cache entry updated\n * @returns {T|undefined}\n */\nCacheEntry.prototype.get = function(callback) {\n  if (!callback) {\n    return this._value;\n  } else {\n    this.once('value', callback);\n    if (!_.isUndefined(this._value)) {\n      this.emit('value', this._value);\n    }\n  }\n};\n\n/**\n * Set value in the cache entry\n *\n * @param {T} [value] - A value for caching\n */\nCacheEntry.prototype.set = function(value) {\n  this._value = value;\n  this.emit('value', this._value);\n};\n\n/**\n * Clear cached value\n */\nCacheEntry.prototype.clear = function() {\n  this.fetching = false;\n  delete this._value;\n};\n\n\n/**\n * Caching manager for async methods\n *\n * @class\n * @constructor\n */\nvar Cache = function() {\n  this._entries = {};\n};\n\n/**\n * retrive cache entry, or create if not exists.\n *\n * @param {String} [key] - Key of cache entry\n * @returns {CacheEntry}\n */\nCache.prototype.get = function(key) {\n  if (key && this._entries[key]) {\n    return this._entries[key];\n  } else {\n    var entry = new CacheEntry();\n    this._entries[key] = entry;\n    return entry;\n  }\n};\n\n/**\n * clear cache entries prefix matching given key\n * @param {String} [key] - Key prefix of cache entry to clear\n */\nCache.prototype.clear = function(key) {\n  for (var k in this._entries) {\n    if (!key || k.indexOf(key) === 0) {\n      this._entries[k].clear();\n    }\n  }\n};\n\n/**\n * create and return cache key from namespace and serialized arguments.\n * @private\n */\nfunction createCacheKey(namespace, args) {\n  args = Array.prototype.slice.apply(args);\n  return namespace + '(' + _.map(args, function(a){ return JSON.stringify(a); }).join(',') + ')';\n}\n\n/**\n * Enable caching for async call fn to intercept the response and store it to cache.\n * The original async calll fn is always invoked.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeResponseCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  return function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n      callback = null;\n    }\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, args) :\n              createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n    entry.fetching = true;\n    if (callback) {\n      args.push(function(err, result) {\n        entry.set({ error: err, result: result });\n        callback(err, result);\n      });\n    }\n    var ret, error;\n    try {\n      ret = fn.apply(scope || this, args);\n    } catch(e) {\n      error = e;\n    }\n    if (ret && _.isFunction(ret.then)) { // if the returned value is promise\n      if (!callback) {\n        return ret.then(function(result) {\n          entry.set({ error: undefined, result: result });\n          return result;\n        }, function(err) {\n          entry.set({ error: err, result: undefined });\n          throw err;\n        });\n      } else {\n        return ret;\n      }\n    } else {\n      entry.set({ error: error, result: ret });\n      if (error) { throw error; }\n      return ret;\n    }\n  };\n};\n\n/**\n * Enable caching for async call fn to lookup the response cache first, then invoke original if no cached value.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  var $fn = function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n    }\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, args) :\n              createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n    if (!_.isFunction(callback)) { // if callback is not given in last arg, return cached result (immediate).\n      var value = entry.get();\n      if (!value) { throw new Error('Function call result is not cached yet.'); }\n      if (value.error) { throw value.error; }\n      return value.result;\n    }\n    entry.get(function(value) {\n      callback(value.error, value.result);\n    });\n    if (!entry.fetching) { // only when no other client is calling function\n      entry.fetching = true;\n      args.push(function(err, result) {\n        entry.set({ error: err, result: result });\n      });\n      fn.apply(scope || this, args);\n    }\n  };\n  $fn.clear = function() {\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, arguments) :\n              createCacheKey(options.namespace, arguments);\n    cache.clear(key);\n  };\n  return $fn;\n};\n\n\nmodule.exports = Cache;\n"]},"metadata":{},"sourceType":"script"}