{"ast":null,"code":"\"use strict\";\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\n\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar ResizeableBuffer = require('./ResizeableBuffer');\n\nvar tab = 9;\nvar nl = 10;\nvar np = 12;\nvar cr = 13;\nvar space = 32;\nvar bom_utf8 = Buffer.from([239, 187, 191]);\n\nvar Parser = /*#__PURE__*/function (_Transform) {\n  _inherits(Parser, _Transform);\n\n  var _super = _createSuper(Parser);\n\n  function Parser() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Parser);\n\n    _this = _super.call(this, _objectSpread(_objectSpread({}, {\n      readableObjectMode: true\n    }), opts));\n    var options = {}; // Merge with user options\n\n    for (var opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    } // Normalize option `bom`\n\n\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', \"got \".concat(JSON.stringify(options.bom))]);\n    } // Normalize option `cast`\n\n\n    var fnCastField = null;\n\n    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n      options.cast = undefined;\n    } else if (typeof options.cast === 'function') {\n      fnCastField = options.cast;\n      options.cast = true;\n    } else if (options.cast !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', \"got \".concat(JSON.stringify(options.cast))]);\n    } // Normalize option `cast_date`\n\n\n    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n      options.cast_date = false;\n    } else if (options.cast_date === true) {\n      options.cast_date = function (value) {\n        var date = Date.parse(value);\n        return !isNaN(date) ? new Date(date) : value;\n      };\n    } else if (typeof options.cast_date !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', \"got \".concat(JSON.stringify(options.cast_date))]);\n    } // Normalize option `columns`\n\n\n    var fnFirstLineToHeaders = null;\n\n    if (options.columns === true) {\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined;\n    } else if (typeof options.columns === 'function') {\n      fnFirstLineToHeaders = options.columns;\n      options.columns = true;\n    } else if (Array.isArray(options.columns)) {\n      options.columns = normalizeColumnsArray(options.columns);\n    } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n      options.columns = false;\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an object, a function or true,', \"got \".concat(JSON.stringify(options.columns))]);\n    } // Normalize option `columns_duplicates_to_array`\n\n\n    if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n      options.columns_duplicates_to_array = false;\n    } else if (options.columns_duplicates_to_array !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'expect an boolean,', \"got \".concat(JSON.stringify(options.columns_duplicates_to_array))]);\n    } // Normalize option `comment`\n\n\n    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n      options.comment = null;\n    } else {\n      if (typeof options.comment === 'string') {\n        options.comment = Buffer.from(options.comment);\n      }\n\n      if (!Buffer.isBuffer(options.comment)) {\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', \"got \".concat(JSON.stringify(options.comment))]);\n      }\n    } // Normalize option `delimiter`\n\n\n    var delimiter_json = JSON.stringify(options.delimiter);\n    if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n    if (options.delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)]);\n    }\n\n    options.delimiter = options.delimiter.map(function (delimiter) {\n      if (delimiter === undefined || delimiter === null || delimiter === false) {\n        return Buffer.from(',');\n      }\n\n      if (typeof delimiter === 'string') {\n        delimiter = Buffer.from(delimiter);\n      }\n\n      if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)]);\n      }\n\n      return delimiter;\n    }); // Normalize option `escape`\n\n    if (options.escape === undefined || options.escape === true) {\n      options.escape = Buffer.from('\"');\n    } else if (typeof options.escape === 'string') {\n      options.escape = Buffer.from(options.escape);\n    } else if (options.escape === null || options.escape === false) {\n      options.escape = null;\n    }\n\n    if (options.escape !== null) {\n      if (!Buffer.isBuffer(options.escape)) {\n        throw new Error(\"Invalid Option: escape must be a buffer, a string or a boolean, got \".concat(JSON.stringify(options.escape)));\n      } else if (options.escape.length !== 1) {\n        throw new Error(\"Invalid Option Length: escape must be one character, got \".concat(options.escape.length));\n      } else {\n        options.escape = options.escape[0];\n      }\n    } // Normalize option `from`\n\n\n    if (options.from === undefined || options.from === null) {\n      options.from = 1;\n    } else {\n      if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n        options.from = parseInt(options.from);\n      }\n\n      if (Number.isInteger(options.from)) {\n        if (options.from < 0) {\n          throw new Error(\"Invalid Option: from must be a positive integer, got \".concat(JSON.stringify(opts.from)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from must be an integer, got \".concat(JSON.stringify(options.from)));\n      }\n    } // Normalize option `from_line`\n\n\n    if (options.from_line === undefined || options.from_line === null) {\n      options.from_line = 1;\n    } else {\n      if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n        options.from_line = parseInt(options.from_line);\n      }\n\n      if (Number.isInteger(options.from_line)) {\n        if (options.from_line <= 0) {\n          throw new Error(\"Invalid Option: from_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.from_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from_line must be an integer, got \".concat(JSON.stringify(opts.from_line)));\n      }\n    } // Normalize option `info`\n\n\n    if (options.info === undefined || options.info === null || options.info === false) {\n      options.info = false;\n    } else if (options.info !== true) {\n      throw new Error(\"Invalid Option: info must be true, got \".concat(JSON.stringify(options.info)));\n    } // Normalize option `max_record_size`\n\n\n    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n      options.max_record_size = 0;\n    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n    } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n      options.max_record_size = parseInt(options.max_record_size);\n    } else {\n      throw new Error(\"Invalid Option: max_record_size must be a positive integer, got \".concat(JSON.stringify(options.max_record_size)));\n    } // Normalize option `objname`\n\n\n    if (options.objname === undefined || options.objname === null || options.objname === false) {\n      options.objname = undefined;\n    } else if (Buffer.isBuffer(options.objname)) {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty buffer\");\n      }\n\n      options.objname = options.objname.toString();\n    } else if (typeof options.objname === 'string') {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty string\");\n      } // Great, nothing to do\n\n    } else {\n      throw new Error(\"Invalid Option: objname must be a string or a buffer, got \".concat(options.objname));\n    } // Normalize option `on_record`\n\n\n    if (options.on_record === undefined || options.on_record === null) {\n      options.on_record = undefined;\n    } else if (typeof options.on_record !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', \"got \".concat(JSON.stringify(options.on_record))]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === null || options.quote === false || options.quote === '') {\n      options.quote = null;\n    } else {\n      if (options.quote === undefined || options.quote === true) {\n        options.quote = Buffer.from('\"');\n      } else if (typeof options.quote === 'string') {\n        options.quote = Buffer.from(options.quote);\n      }\n\n      if (!Buffer.isBuffer(options.quote)) {\n        throw new Error(\"Invalid Option: quote must be a buffer or a string, got \".concat(JSON.stringify(options.quote)));\n      } else if (options.quote.length !== 1) {\n        throw new Error(\"Invalid Option Length: quote must be one character, got \".concat(options.quote.length));\n      } else {\n        options.quote = options.quote[0];\n      }\n    } // Normalize option `raw`\n\n\n    if (options.raw === undefined || options.raw === null || options.raw === false) {\n      options.raw = false;\n    } else if (options.raw !== true) {\n      throw new Error(\"Invalid Option: raw must be true, got \".concat(JSON.stringify(options.raw)));\n    } // Normalize option `record_delimiter`\n\n\n    if (!options.record_delimiter) {\n      options.record_delimiter = [];\n    } else if (!Array.isArray(options.record_delimiter)) {\n      options.record_delimiter = [options.record_delimiter];\n    }\n\n    options.record_delimiter = options.record_delimiter.map(function (rd) {\n      if (typeof rd === 'string') {\n        rd = Buffer.from(rd);\n      }\n\n      return rd;\n    }); // Normalize option `relax`\n\n    if (typeof options.relax === 'boolean') {// Great, nothing to do\n    } else if (options.relax === undefined || options.relax === null) {\n      options.relax = false;\n    } else {\n      throw new Error(\"Invalid Option: relax must be a boolean, got \".concat(JSON.stringify(options.relax)));\n    } // Normalize option `relax_column_count`\n\n\n    if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n      options.relax_column_count = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count must be a boolean, got \".concat(JSON.stringify(options.relax_column_count)));\n    }\n\n    if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n      options.relax_column_count_less = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_less must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_less)));\n    }\n\n    if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n      options.relax_column_count_more = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_more must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_more)));\n    } // Normalize option `skip_empty_lines`\n\n\n    if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n      options.skip_empty_lines = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_empty_lines must be a boolean, got \".concat(JSON.stringify(options.skip_empty_lines)));\n    } // Normalize option `skip_lines_with_empty_values`\n\n\n    if (typeof options.skip_lines_with_empty_values === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n      options.skip_lines_with_empty_values = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_empty_values must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_empty_values)));\n    } // Normalize option `skip_lines_with_error`\n\n\n    if (typeof options.skip_lines_with_error === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n      options.skip_lines_with_error = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_error must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_error)));\n    } // Normalize option `rtrim`\n\n\n    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n      options.rtrim = false;\n    } else if (options.rtrim !== true) {\n      throw new Error(\"Invalid Option: rtrim must be a boolean, got \".concat(JSON.stringify(options.rtrim)));\n    } // Normalize option `ltrim`\n\n\n    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n      options.ltrim = false;\n    } else if (options.ltrim !== true) {\n      throw new Error(\"Invalid Option: ltrim must be a boolean, got \".concat(JSON.stringify(options.ltrim)));\n    } // Normalize option `trim`\n\n\n    if (options.trim === undefined || options.trim === null || options.trim === false) {\n      options.trim = false;\n    } else if (options.trim !== true) {\n      throw new Error(\"Invalid Option: trim must be a boolean, got \".concat(JSON.stringify(options.trim)));\n    } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n    if (options.trim === true && opts.ltrim !== false) {\n      options.ltrim = true;\n    } else if (options.ltrim !== true) {\n      options.ltrim = false;\n    }\n\n    if (options.trim === true && opts.rtrim !== false) {\n      options.rtrim = true;\n    } else if (options.rtrim !== true) {\n      options.rtrim = false;\n    } // Normalize option `to`\n\n\n    if (options.to === undefined || options.to === null) {\n      options.to = -1;\n    } else {\n      if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n        options.to = parseInt(options.to);\n      }\n\n      if (Number.isInteger(options.to)) {\n        if (options.to <= 0) {\n          throw new Error(\"Invalid Option: to must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to must be an integer, got \".concat(JSON.stringify(opts.to)));\n      }\n    } // Normalize option `to_line`\n\n\n    if (options.to_line === undefined || options.to_line === null) {\n      options.to_line = -1;\n    } else {\n      if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n        options.to_line = parseInt(options.to_line);\n      }\n\n      if (Number.isInteger(options.to_line)) {\n        if (options.to_line <= 0) {\n          throw new Error(\"Invalid Option: to_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to_line must be an integer, got \".concat(JSON.stringify(opts.to_line)));\n      }\n    }\n\n    _this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    };\n    _this.options = options;\n    _this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, _this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max.apply(Math, _toConsumableArray(options.record_delimiter.map(function (v) {\n        return v.length;\n      }))),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    };\n    return _this;\n  } // Implementation of `Transform._transform`\n\n\n  _createClass(Parser, [{\n    key: \"_transform\",\n    value: function _transform(buf, encoding, callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(buf, false);\n\n      if (err !== undefined) {\n        this.state.stop = true;\n      }\n\n      callback(err);\n    } // Implementation of `Transform._flush`\n\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(undefined, true);\n\n      callback(err);\n    } // Central parser implementation\n\n  }, {\n    key: \"__parse\",\n    value: function __parse(nextBuf, end) {\n      var _this$options = this.options,\n          bom = _this$options.bom,\n          comment = _this$options.comment,\n          escape = _this$options.escape,\n          from_line = _this$options.from_line,\n          info = _this$options.info,\n          ltrim = _this$options.ltrim,\n          max_record_size = _this$options.max_record_size,\n          quote = _this$options.quote,\n          raw = _this$options.raw,\n          relax = _this$options.relax,\n          rtrim = _this$options.rtrim,\n          skip_empty_lines = _this$options.skip_empty_lines,\n          to = _this$options.to,\n          to_line = _this$options.to_line;\n      var record_delimiter = this.options.record_delimiter;\n      var _this$state = this.state,\n          bomSkipped = _this$state.bomSkipped,\n          previousBuf = _this$state.previousBuf,\n          rawBuffer = _this$state.rawBuffer,\n          escapeIsQuote = _this$state.escapeIsQuote;\n      var buf;\n\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          this.push(null);\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      } // Handle UTF BOM\n\n\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          } // skip BOM detect because data length < 3\n\n        } else {\n          if (bom_utf8.compare(buf, 0, 3) === 0) {\n            // Skip BOM\n            buf = buf.slice(3);\n          }\n\n          this.state.bomSkipped = true;\n        }\n      }\n\n      var bufLen = buf.length;\n      var pos;\n\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n\n          if (info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false) {\n            this.state.info = Object.assign({}, this.info);\n          }\n\n          this.state.wasRowDelimiter = false;\n        }\n\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          this.push(null);\n          return;\n        } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          var record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos);\n\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n\n        var chr = buf[pos];\n\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        } // Previous char was a valid escape char\n        // treat the current char as a regular char\n\n\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          if (escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen) {\n            if (escapeIsQuote) {\n              if (buf[pos + 1] === quote) {\n                this.state.escaping = true;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              continue;\n            }\n          } // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n\n\n          if (this.state.commenting === false && chr === quote) {\n            if (this.state.quoting === true) {\n              var nextChr = buf[pos + 1];\n\n              var isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr); // const isNextChrComment = nextChr === comment\n\n\n              var isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + 1, nextChr);\n\n              var isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos + 1);\n\n              var isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos + 1) : this.__isRecordDelimiter(nextChr, buf, pos + 1); // Escape a quote\n              // Treat next char as a regular character\n              // TODO: need to compare bytes instead of single char\n\n              if (escape !== null && chr === escape && nextChr === quote) {\n                pos++;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                continue;\n              } else if (relax === false) {\n                var err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', \"got \\\"\".concat(String.fromCharCode(nextChr), \"\\\"\"), \"at line \".concat(this.info.lines), 'instead of delimiter, row delimiter, trimable character', '(if activated) or comment'], this.__context()));\n\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true; // continue\n\n                this.state.field.prepend(quote);\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax mode, treat opening quote preceded by chrs as regular\n                if (relax === false) {\n                  var _err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', \"a quote is found inside a field at line \".concat(this.info.lines)], this.__context(), {\n                    field: this.state.field\n                  }));\n\n                  if (_err !== undefined) return _err;\n                }\n              } else {\n                this.state.quoting = true;\n                continue;\n              }\n            }\n          }\n\n          if (this.state.quoting === false) {\n            var recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              var skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n              if (skipCommentLine) {\n                this.info.comment_lines++; // Skip full comment line\n              } else {\n                // Skip if line is empty and skip_empty_lines activated\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } // Activate records emition if above from_line\n\n\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n\n                  this.__resetField();\n\n                  this.__resetRow();\n\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } else {\n                  var errField = this.__onField();\n\n                  if (errField !== undefined) return errField;\n\n                  var errRecord = this.__onRow();\n\n                  if (errRecord !== undefined) return errRecord;\n                }\n\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  this.push(null);\n                  return;\n                }\n              }\n\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n\n            if (this.state.commenting) {\n              continue;\n            }\n\n            var commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n\n            var delimiterLength = this.__isDelimiter(chr, buf, pos);\n\n            if (delimiterLength !== 0) {\n              var _errField = this.__onField();\n\n              if (_errField !== undefined) return _errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            var _err2 = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', \"of \".concat(max_record_size), \"at line \".concat(this.info.lines)], this.__context()));\n\n            if (_err2 !== undefined) return _err2;\n          }\n        }\n\n        var lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField\n\n        var rappend = rtrim === false || this.state.wasQuoting === false;\n\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n          var _err3 = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', \"at line \".concat(this.info.lines)], this.__context()));\n\n          if (_err3 !== undefined) return _err3;\n        }\n      }\n\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          var _err4 = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', \"the parsing is finished with an opening quote at line \".concat(this.info.lines)], this.__context()));\n\n          if (_err4 !== undefined) return _err4;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            var _errField2 = this.__onField();\n\n            if (_errField2 !== undefined) return _errField2;\n\n            var _errRecord = this.__onRow();\n\n            if (_errRecord !== undefined) return _errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.previousBuf = buf.slice(pos);\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    } // Helper to test if a character is a space or a line delimiter\n\n  }, {\n    key: \"__isCharTrimable\",\n    value: function __isCharTrimable(chr) {\n      return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n    }\n  }, {\n    key: \"__onRow\",\n    value: function __onRow() {\n      var _this$options2 = this.options,\n          columns = _this$options2.columns,\n          columns_duplicates_to_array = _this$options2.columns_duplicates_to_array,\n          info = _this$options2.info,\n          from = _this$options2.from,\n          relax_column_count = _this$options2.relax_column_count,\n          relax_column_count_less = _this$options2.relax_column_count_less,\n          relax_column_count_more = _this$options2.relax_column_count_more,\n          raw = _this$options2.raw,\n          skip_lines_with_empty_values = _this$options2.skip_lines_with_empty_values;\n      var _this$state2 = this.state,\n          enabled = _this$state2.enabled,\n          record = _this$state2.record;\n\n      if (enabled === false) {\n        return this.__resetRow();\n      } // Convert the first line into column names\n\n\n      var recordLength = record.length;\n\n      if (columns === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRow();\n\n          return;\n        }\n\n        return this.__firstLineToColumns(record);\n      }\n\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n\n      if (recordLength !== this.state.expectedRecordLength) {\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n        } else {\n          if (columns === false) {\n            var err = this.__error(new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', \"expect \".concat(this.state.expectedRecordLength, \",\"), \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.__context(), {\n              record: record\n            }));\n\n            if (err !== undefined) return err;\n          } else {\n            var _err5 = this.__error( // CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS\n            new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', \"columns length is \".concat(columns.length, \",\"), // rename columns\n            \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.__context(), {\n              record: record\n            }));\n\n            if (_err5 !== undefined) return _err5;\n          }\n        }\n      }\n\n      if (skip_lines_with_empty_values === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRow();\n\n          return;\n        }\n      }\n\n      if (this.state.recordHasError === true) {\n        this.__resetRow();\n\n        this.state.recordHasError = false;\n        return;\n      }\n\n      this.info.records++;\n\n      if (from === 1 || this.info.records >= from) {\n        if (columns !== false) {\n          var obj = {}; // Transform record array to an object\n\n          for (var i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue; // obj[columns[i].name] = record[i]\n            // Turn duplicate columns into an array\n\n            if (columns_duplicates_to_array === true && obj[columns[i].name]) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n\n          var objname = this.options.objname;\n\n          if (objname === undefined) {\n            if (raw === true || info === true) {\n              var _err6 = this.__push(Object.assign({\n                record: obj\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString()\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err6) {\n                return _err6;\n              }\n            } else {\n              var _err7 = this.__push(obj);\n\n              if (_err7) {\n                return _err7;\n              }\n            }\n          } else {\n            if (raw === true || info === true) {\n              var _err8 = this.__push(Object.assign({\n                record: [obj[objname], obj]\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString()\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err8) {\n                return _err8;\n              }\n            } else {\n              var _err9 = this.__push([obj[objname], obj]);\n\n              if (_err9) {\n                return _err9;\n              }\n            }\n          }\n        } else {\n          if (raw === true || info === true) {\n            var _err10 = this.__push(Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString()\n            } : {}, info === true ? {\n              info: this.state.info\n            } : {}));\n\n            if (_err10) {\n              return _err10;\n            }\n          } else {\n            var _err11 = this.__push(record);\n\n            if (_err11) {\n              return _err11;\n            }\n          }\n        }\n      }\n\n      this.__resetRow();\n    }\n  }, {\n    key: \"__firstLineToColumns\",\n    value: function __firstLineToColumns(record) {\n      var firstLineToHeaders = this.state.firstLineToHeaders;\n\n      try {\n        var headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', \"got \".concat(JSON.stringify(headers))], this.__context(), {\n            headers: headers\n          }));\n        }\n\n        var normalizedHeaders = normalizeColumnsArray(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n\n        this.__resetRow();\n\n        return;\n      } catch (err) {\n        return err;\n      }\n    }\n  }, {\n    key: \"__resetRow\",\n    value: function __resetRow() {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n\n      this.state.record = [];\n      this.state.record_length = 0;\n    }\n  }, {\n    key: \"__onField\",\n    value: function __onField() {\n      var _this$options3 = this.options,\n          cast = _this$options3.cast,\n          rtrim = _this$options3.rtrim,\n          max_record_size = _this$options3.max_record_size;\n      var _this$state3 = this.state,\n          enabled = _this$state3.enabled,\n          wasQuoting = _this$state3.wasQuoting; // Short circuit for the from_line options\n\n      if (enabled === false) {\n        /* this.options.columns !== true && */\n        return this.__resetField();\n      }\n\n      var field = this.state.field.toString();\n\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n\n      if (cast === true) {\n        var _this$__cast = this.__cast(field),\n            _this$__cast2 = _slicedToArray(_this$__cast, 2),\n            err = _this$__cast2[0],\n            f = _this$__cast2[1];\n\n        if (err !== undefined) return err;\n        field = f;\n      }\n\n      this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n\n      this.__resetField();\n    }\n  }, {\n    key: \"__resetField\",\n    value: function __resetField() {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    }\n  }, {\n    key: \"__push\",\n    value: function __push(record) {\n      var on_record = this.options.on_record;\n\n      if (on_record !== undefined) {\n        var context = this.__context();\n\n        try {\n          record = on_record.call(null, record, context);\n        } catch (err) {\n          return err;\n        }\n\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n\n      this.push(record);\n    } // Return a tuple with the error and the casted value\n\n  }, {\n    key: \"__cast\",\n    value: function __cast(field) {\n      var _this$options4 = this.options,\n          columns = _this$options4.columns,\n          relax_column_count = _this$options4.relax_column_count;\n      var isColumns = Array.isArray(columns); // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n\n      var context = this.__context();\n\n      if (this.state.castField !== null) {\n        try {\n          return [undefined, this.state.castField.call(null, field, context)];\n        } catch (err) {\n          return [err];\n        }\n      }\n\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        return [undefined, this.options.cast_date.call(null, field, context)];\n      }\n\n      return [undefined, field];\n    } // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n\n  }, {\n    key: \"__isFloat\",\n    value: function __isFloat(value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    }\n  }, {\n    key: \"__compareBytes\",\n    value: function __compareBytes(sourceBuf, targetBuf, pos, firtByte) {\n      if (sourceBuf[0] !== firtByte) return 0;\n      var sourceLength = sourceBuf.length;\n\n      for (var i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[pos + i]) return 0;\n      }\n\n      return sourceLength;\n    }\n  }, {\n    key: \"__needMoreData\",\n    value: function __needMoreData(i, bufLen, end) {\n      if (end) {\n        return false;\n      }\n\n      var _this$options5 = this.options,\n          comment = _this$options5.comment,\n          delimiter = _this$options5.delimiter;\n      var _this$state4 = this.state,\n          quoting = _this$state4.quoting,\n          recordDelimiterMaxLength = _this$state4.recordDelimiterMaxLength;\n      var numOfCharLeft = bufLen - i - 1;\n      var requiredLength = Math.max( // Skip if the remaining buffer smaller than comment\n      comment ? comment.length : 0, // Skip if the remaining buffer smaller than row delimiter\n      recordDelimiterMaxLength, // Skip if the remaining buffer can be row delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? 1 + recordDelimiterMaxLength : 0, // Skip if the remaining buffer can be delimiter\n      delimiter.length, // Skip if the remaining buffer can be escape sequence\n      // 1 is for escape.length\n      1);\n      return numOfCharLeft < requiredLength;\n    }\n  }, {\n    key: \"__isDelimiter\",\n    value: function __isDelimiter(chr, buf, pos) {\n      var delimiter = this.options.delimiter;\n\n      loop1: for (var i = 0; i < delimiter.length; i++) {\n        var del = delimiter[i];\n\n        if (del[0] === chr) {\n          for (var j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return del.length;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__isRecordDelimiter\",\n    value: function __isRecordDelimiter(chr, buf, pos) {\n      var record_delimiter = this.options.record_delimiter;\n      var recordDelimiterLength = record_delimiter.length;\n\n      loop1: for (var i = 0; i < recordDelimiterLength; i++) {\n        var rd = record_delimiter[i];\n        var rdLength = rd.length;\n\n        if (rd[0] !== chr) {\n          continue;\n        }\n\n        for (var j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n\n        return rd.length;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__autoDiscoverRowDelimiter\",\n    value: function __autoDiscoverRowDelimiter(buf, pos) {\n      var chr = buf[pos];\n\n      if (chr === cr) {\n        if (buf[pos + 1] === nl) {\n          this.options.record_delimiter.push(Buffer.from('\\r\\n'));\n          this.state.recordDelimiterMaxLength = 2;\n          return 2;\n        } else {\n          this.options.record_delimiter.push(Buffer.from('\\r'));\n          this.state.recordDelimiterMaxLength = 1;\n          return 1;\n        }\n      } else if (chr === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\n'));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__error\",\n    value: function __error(msg) {\n      var skip_lines_with_error = this.options.skip_lines_with_error;\n      var err = typeof msg === 'string' ? new Error(msg) : msg;\n\n      if (skip_lines_with_error) {\n        this.state.recordHasError = true;\n        this.emit('skip', err);\n        return undefined;\n      } else {\n        return err;\n      }\n    }\n  }, {\n    key: \"__context\",\n    value: function __context() {\n      var columns = this.options.columns;\n      var isColumns = Array.isArray(columns);\n      return {\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        empty_lines: this.info.empty_lines,\n        header: columns === true,\n        index: this.state.record.length,\n        invalid_field_length: this.info.invalid_field_length,\n        quoting: this.state.wasQuoting,\n        lines: this.info.lines,\n        records: this.info.records\n      };\n    }\n  }]);\n\n  return Parser;\n}(Transform);\n\nvar parse = function parse() {\n  var data, options, callback;\n\n  for (var i in arguments) {\n    var argument = arguments[i];\n\n    var type = _typeof(argument);\n\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(i)]);\n    }\n  }\n\n  var parser = new Parser(options);\n\n  if (callback) {\n    var records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      var record;\n\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.info);\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.info);\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n\n  return parser;\n};\n\nvar CsvError = /*#__PURE__*/function (_Error) {\n  _inherits(CsvError, _Error);\n\n  var _super2 = _createSuper(CsvError);\n\n  function CsvError(code, message) {\n    var _this2;\n\n    _classCallCheck(this, CsvError);\n\n    if (Array.isArray(message)) message = message.join(' ');\n    _this2 = _super2.call(this, message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_this2), CsvError);\n    }\n\n    _this2.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      contexts[_key - 2] = arguments[_key];\n    }\n\n    for (var _i2 = 0, _contexts = contexts; _i2 < _contexts.length; _i2++) {\n      var context = _contexts[_i2];\n\n      for (var key in context) {\n        var value = context[key];\n        _this2[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n\n    return _this2;\n  }\n\n  return CsvError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\n\nvar underscore = function underscore(str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nvar isObject = function isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar isRecordEmpty = function isRecordEmpty(record) {\n  return record.every(function (field) {\n    return field == null || field.toString && field.toString().trim() === '';\n  });\n};\n\nvar normalizeColumnsArray = function normalizeColumnsArray(columns) {\n  var normalizedColumns = [];\n\n  for (var i = 0, l = columns.length; i < l; i++) {\n    var column = columns[i];\n\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', \"property \\\"name\\\" is required at position \".concat(i), 'when column is an object literal']);\n      }\n\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', \"got \".concat(JSON.stringify(column), \" at position \").concat(i)]);\n    }\n  }\n\n  return normalizedColumns;\n};","map":{"version":3,"sources":["/Users/gcarminati/Desktop/OmniStudio/OmniProxy/react-express-proxy-sample/node_modules/csv-parse/lib/es5/index.js"],"names":["_wrapNativeSuper","Class","_cache","Map","undefined","_isNativeFunction","TypeError","has","get","set","Wrapper","_construct","arguments","_getPrototypeOf","constructor","prototype","Object","create","value","enumerable","writable","configurable","_setPrototypeOf","Parent","args","_isNativeReflectConstruct","Reflect","construct","a","push","apply","Constructor","Function","bind","instance","fn","toString","call","indexOf","_typeof","obj","Symbol","iterator","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_arr","_n","_d","_e","_i","_s","next","done","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","slice","name","from","test","iter","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_classCallCheck","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_inherits","subClass","superClass","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Date","e","getPrototypeOf","_require","require","Transform","ResizeableBuffer","tab","nl","np","cr","space","bom_utf8","Buffer","Parser","_Transform","_super","_this","opts","readableObjectMode","options","opt","underscore","bom","CsvError","concat","JSON","stringify","fnCastField","cast","cast_date","date","parse","isNaN","fnFirstLineToHeaders","columns","normalizeColumnsArray","columns_duplicates_to_array","comment","isBuffer","delimiter_json","delimiter","map","escape","Error","parseInt","Number","isInteger","from_line","info","max_record_size","objname","on_record","quote","raw","record_delimiter","rd","relax","relax_column_count","relax_column_count_less","relax_column_count_more","skip_empty_lines","skip_lines_with_empty_values","skip_lines_with_error","rtrim","ltrim","trim","to","to_line","comment_lines","empty_lines","invalid_field_length","lines","records","state","bomSkipped","castField","commenting","enabled","escaping","escapeIsQuote","expectedRecordLength","field","firstLineToHeaders","assign","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","Math","max","v","trimChars","wasQuoting","wasRowDelimiter","_transform","buf","encoding","callback","__parse","_flush","nextBuf","end","_this$options","_this$state","compare","bufLen","pos","__needMoreData","record_delimiterCount","__autoDiscoverRowDelimiter","chr","append","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRowDelimiter","__isRecordDelimiter","__error","String","fromCharCode","__context","prepend","_err","recordDelimiterLength","skipCommentLine","__resetField","__resetRow","errField","__onField","errRecord","__onRow","commentCount","delimiterLength","_errField","_err2","lappend","rappend","_err3","_err4","_errField2","_errRecord","_this$options2","_this$state2","recordLength","isRecordEmpty","__firstLineToColumns","_err5","l","disabled","_err6","__push","_err7","_err8","_err9","_err10","_err11","headers","normalizedHeaders","reset","_this$options3","_this$state3","trimRight","_this$__cast","__cast","_this$__cast2","f","context","_this$options4","isColumns","__isFloat","parseFloat","sourceBuf","targetBuf","firtByte","sourceLength","_this$options5","_this$state4","numOfCharLeft","requiredLength","loop1","del","j","rdLength","msg","emit","column","header","index","data","argument","type","isObject","parser","on","read","setImmediate","write","_Error","_super2","code","message","_this2","join","captureStackTrace","_len","contexts","_key","_i2","_contexts","module","exports","str","replace","_","match","toLowerCase","every","normalizedColumns"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar ResizeableBuffer = require('./ResizeableBuffer');\n\nvar tab = 9;\nvar nl = 10;\nvar np = 12;\nvar cr = 13;\nvar space = 32;\nvar bom_utf8 = Buffer.from([239, 187, 191]);\n\nvar Parser = /*#__PURE__*/function (_Transform) {\n  _inherits(Parser, _Transform);\n\n  var _super = _createSuper(Parser);\n\n  function Parser() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Parser);\n\n    _this = _super.call(this, _objectSpread(_objectSpread({}, {\n      readableObjectMode: true\n    }), opts));\n    var options = {}; // Merge with user options\n\n    for (var opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    } // Normalize option `bom`\n\n\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', \"got \".concat(JSON.stringify(options.bom))]);\n    } // Normalize option `cast`\n\n\n    var fnCastField = null;\n\n    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n      options.cast = undefined;\n    } else if (typeof options.cast === 'function') {\n      fnCastField = options.cast;\n      options.cast = true;\n    } else if (options.cast !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', \"got \".concat(JSON.stringify(options.cast))]);\n    } // Normalize option `cast_date`\n\n\n    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n      options.cast_date = false;\n    } else if (options.cast_date === true) {\n      options.cast_date = function (value) {\n        var date = Date.parse(value);\n        return !isNaN(date) ? new Date(date) : value;\n      };\n    } else if (typeof options.cast_date !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', \"got \".concat(JSON.stringify(options.cast_date))]);\n    } // Normalize option `columns`\n\n\n    var fnFirstLineToHeaders = null;\n\n    if (options.columns === true) {\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined;\n    } else if (typeof options.columns === 'function') {\n      fnFirstLineToHeaders = options.columns;\n      options.columns = true;\n    } else if (Array.isArray(options.columns)) {\n      options.columns = normalizeColumnsArray(options.columns);\n    } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n      options.columns = false;\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an object, a function or true,', \"got \".concat(JSON.stringify(options.columns))]);\n    } // Normalize option `columns_duplicates_to_array`\n\n\n    if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n      options.columns_duplicates_to_array = false;\n    } else if (options.columns_duplicates_to_array !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'expect an boolean,', \"got \".concat(JSON.stringify(options.columns_duplicates_to_array))]);\n    } // Normalize option `comment`\n\n\n    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n      options.comment = null;\n    } else {\n      if (typeof options.comment === 'string') {\n        options.comment = Buffer.from(options.comment);\n      }\n\n      if (!Buffer.isBuffer(options.comment)) {\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', \"got \".concat(JSON.stringify(options.comment))]);\n      }\n    } // Normalize option `delimiter`\n\n\n    var delimiter_json = JSON.stringify(options.delimiter);\n    if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n    if (options.delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)]);\n    }\n\n    options.delimiter = options.delimiter.map(function (delimiter) {\n      if (delimiter === undefined || delimiter === null || delimiter === false) {\n        return Buffer.from(',');\n      }\n\n      if (typeof delimiter === 'string') {\n        delimiter = Buffer.from(delimiter);\n      }\n\n      if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)]);\n      }\n\n      return delimiter;\n    }); // Normalize option `escape`\n\n    if (options.escape === undefined || options.escape === true) {\n      options.escape = Buffer.from('\"');\n    } else if (typeof options.escape === 'string') {\n      options.escape = Buffer.from(options.escape);\n    } else if (options.escape === null || options.escape === false) {\n      options.escape = null;\n    }\n\n    if (options.escape !== null) {\n      if (!Buffer.isBuffer(options.escape)) {\n        throw new Error(\"Invalid Option: escape must be a buffer, a string or a boolean, got \".concat(JSON.stringify(options.escape)));\n      } else if (options.escape.length !== 1) {\n        throw new Error(\"Invalid Option Length: escape must be one character, got \".concat(options.escape.length));\n      } else {\n        options.escape = options.escape[0];\n      }\n    } // Normalize option `from`\n\n\n    if (options.from === undefined || options.from === null) {\n      options.from = 1;\n    } else {\n      if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n        options.from = parseInt(options.from);\n      }\n\n      if (Number.isInteger(options.from)) {\n        if (options.from < 0) {\n          throw new Error(\"Invalid Option: from must be a positive integer, got \".concat(JSON.stringify(opts.from)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from must be an integer, got \".concat(JSON.stringify(options.from)));\n      }\n    } // Normalize option `from_line`\n\n\n    if (options.from_line === undefined || options.from_line === null) {\n      options.from_line = 1;\n    } else {\n      if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n        options.from_line = parseInt(options.from_line);\n      }\n\n      if (Number.isInteger(options.from_line)) {\n        if (options.from_line <= 0) {\n          throw new Error(\"Invalid Option: from_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.from_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from_line must be an integer, got \".concat(JSON.stringify(opts.from_line)));\n      }\n    } // Normalize option `info`\n\n\n    if (options.info === undefined || options.info === null || options.info === false) {\n      options.info = false;\n    } else if (options.info !== true) {\n      throw new Error(\"Invalid Option: info must be true, got \".concat(JSON.stringify(options.info)));\n    } // Normalize option `max_record_size`\n\n\n    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n      options.max_record_size = 0;\n    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n    } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n      options.max_record_size = parseInt(options.max_record_size);\n    } else {\n      throw new Error(\"Invalid Option: max_record_size must be a positive integer, got \".concat(JSON.stringify(options.max_record_size)));\n    } // Normalize option `objname`\n\n\n    if (options.objname === undefined || options.objname === null || options.objname === false) {\n      options.objname = undefined;\n    } else if (Buffer.isBuffer(options.objname)) {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty buffer\");\n      }\n\n      options.objname = options.objname.toString();\n    } else if (typeof options.objname === 'string') {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty string\");\n      } // Great, nothing to do\n\n    } else {\n      throw new Error(\"Invalid Option: objname must be a string or a buffer, got \".concat(options.objname));\n    } // Normalize option `on_record`\n\n\n    if (options.on_record === undefined || options.on_record === null) {\n      options.on_record = undefined;\n    } else if (typeof options.on_record !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', \"got \".concat(JSON.stringify(options.on_record))]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === null || options.quote === false || options.quote === '') {\n      options.quote = null;\n    } else {\n      if (options.quote === undefined || options.quote === true) {\n        options.quote = Buffer.from('\"');\n      } else if (typeof options.quote === 'string') {\n        options.quote = Buffer.from(options.quote);\n      }\n\n      if (!Buffer.isBuffer(options.quote)) {\n        throw new Error(\"Invalid Option: quote must be a buffer or a string, got \".concat(JSON.stringify(options.quote)));\n      } else if (options.quote.length !== 1) {\n        throw new Error(\"Invalid Option Length: quote must be one character, got \".concat(options.quote.length));\n      } else {\n        options.quote = options.quote[0];\n      }\n    } // Normalize option `raw`\n\n\n    if (options.raw === undefined || options.raw === null || options.raw === false) {\n      options.raw = false;\n    } else if (options.raw !== true) {\n      throw new Error(\"Invalid Option: raw must be true, got \".concat(JSON.stringify(options.raw)));\n    } // Normalize option `record_delimiter`\n\n\n    if (!options.record_delimiter) {\n      options.record_delimiter = [];\n    } else if (!Array.isArray(options.record_delimiter)) {\n      options.record_delimiter = [options.record_delimiter];\n    }\n\n    options.record_delimiter = options.record_delimiter.map(function (rd) {\n      if (typeof rd === 'string') {\n        rd = Buffer.from(rd);\n      }\n\n      return rd;\n    }); // Normalize option `relax`\n\n    if (typeof options.relax === 'boolean') {// Great, nothing to do\n    } else if (options.relax === undefined || options.relax === null) {\n      options.relax = false;\n    } else {\n      throw new Error(\"Invalid Option: relax must be a boolean, got \".concat(JSON.stringify(options.relax)));\n    } // Normalize option `relax_column_count`\n\n\n    if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n      options.relax_column_count = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count must be a boolean, got \".concat(JSON.stringify(options.relax_column_count)));\n    }\n\n    if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n      options.relax_column_count_less = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_less must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_less)));\n    }\n\n    if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n      options.relax_column_count_more = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_more must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_more)));\n    } // Normalize option `skip_empty_lines`\n\n\n    if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n      options.skip_empty_lines = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_empty_lines must be a boolean, got \".concat(JSON.stringify(options.skip_empty_lines)));\n    } // Normalize option `skip_lines_with_empty_values`\n\n\n    if (typeof options.skip_lines_with_empty_values === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n      options.skip_lines_with_empty_values = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_empty_values must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_empty_values)));\n    } // Normalize option `skip_lines_with_error`\n\n\n    if (typeof options.skip_lines_with_error === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n      options.skip_lines_with_error = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_error must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_error)));\n    } // Normalize option `rtrim`\n\n\n    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n      options.rtrim = false;\n    } else if (options.rtrim !== true) {\n      throw new Error(\"Invalid Option: rtrim must be a boolean, got \".concat(JSON.stringify(options.rtrim)));\n    } // Normalize option `ltrim`\n\n\n    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n      options.ltrim = false;\n    } else if (options.ltrim !== true) {\n      throw new Error(\"Invalid Option: ltrim must be a boolean, got \".concat(JSON.stringify(options.ltrim)));\n    } // Normalize option `trim`\n\n\n    if (options.trim === undefined || options.trim === null || options.trim === false) {\n      options.trim = false;\n    } else if (options.trim !== true) {\n      throw new Error(\"Invalid Option: trim must be a boolean, got \".concat(JSON.stringify(options.trim)));\n    } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n    if (options.trim === true && opts.ltrim !== false) {\n      options.ltrim = true;\n    } else if (options.ltrim !== true) {\n      options.ltrim = false;\n    }\n\n    if (options.trim === true && opts.rtrim !== false) {\n      options.rtrim = true;\n    } else if (options.rtrim !== true) {\n      options.rtrim = false;\n    } // Normalize option `to`\n\n\n    if (options.to === undefined || options.to === null) {\n      options.to = -1;\n    } else {\n      if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n        options.to = parseInt(options.to);\n      }\n\n      if (Number.isInteger(options.to)) {\n        if (options.to <= 0) {\n          throw new Error(\"Invalid Option: to must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to must be an integer, got \".concat(JSON.stringify(opts.to)));\n      }\n    } // Normalize option `to_line`\n\n\n    if (options.to_line === undefined || options.to_line === null) {\n      options.to_line = -1;\n    } else {\n      if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n        options.to_line = parseInt(options.to_line);\n      }\n\n      if (Number.isInteger(options.to_line)) {\n        if (options.to_line <= 0) {\n          throw new Error(\"Invalid Option: to_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to_line must be an integer, got \".concat(JSON.stringify(opts.to_line)));\n      }\n    }\n\n    _this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    };\n    _this.options = options;\n    _this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, _this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max.apply(Math, _toConsumableArray(options.record_delimiter.map(function (v) {\n        return v.length;\n      }))),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    };\n    return _this;\n  } // Implementation of `Transform._transform`\n\n\n  _createClass(Parser, [{\n    key: \"_transform\",\n    value: function _transform(buf, encoding, callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(buf, false);\n\n      if (err !== undefined) {\n        this.state.stop = true;\n      }\n\n      callback(err);\n    } // Implementation of `Transform._flush`\n\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.state.stop === true) {\n        return;\n      }\n\n      var err = this.__parse(undefined, true);\n\n      callback(err);\n    } // Central parser implementation\n\n  }, {\n    key: \"__parse\",\n    value: function __parse(nextBuf, end) {\n      var _this$options = this.options,\n          bom = _this$options.bom,\n          comment = _this$options.comment,\n          escape = _this$options.escape,\n          from_line = _this$options.from_line,\n          info = _this$options.info,\n          ltrim = _this$options.ltrim,\n          max_record_size = _this$options.max_record_size,\n          quote = _this$options.quote,\n          raw = _this$options.raw,\n          relax = _this$options.relax,\n          rtrim = _this$options.rtrim,\n          skip_empty_lines = _this$options.skip_empty_lines,\n          to = _this$options.to,\n          to_line = _this$options.to_line;\n      var record_delimiter = this.options.record_delimiter;\n      var _this$state = this.state,\n          bomSkipped = _this$state.bomSkipped,\n          previousBuf = _this$state.previousBuf,\n          rawBuffer = _this$state.rawBuffer,\n          escapeIsQuote = _this$state.escapeIsQuote;\n      var buf;\n\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          this.push(null);\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      } // Handle UTF BOM\n\n\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          } // skip BOM detect because data length < 3\n\n        } else {\n          if (bom_utf8.compare(buf, 0, 3) === 0) {\n            // Skip BOM\n            buf = buf.slice(3);\n          }\n\n          this.state.bomSkipped = true;\n        }\n      }\n\n      var bufLen = buf.length;\n      var pos;\n\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n\n          if (info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false) {\n            this.state.info = Object.assign({}, this.info);\n          }\n\n          this.state.wasRowDelimiter = false;\n        }\n\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          this.push(null);\n          return;\n        } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          var record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos);\n\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n\n        var chr = buf[pos];\n\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        } // Previous char was a valid escape char\n        // treat the current char as a regular char\n\n\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          if (escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen) {\n            if (escapeIsQuote) {\n              if (buf[pos + 1] === quote) {\n                this.state.escaping = true;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              continue;\n            }\n          } // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n\n\n          if (this.state.commenting === false && chr === quote) {\n            if (this.state.quoting === true) {\n              var nextChr = buf[pos + 1];\n\n              var isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr); // const isNextChrComment = nextChr === comment\n\n\n              var isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + 1, nextChr);\n\n              var isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos + 1);\n\n              var isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos + 1) : this.__isRecordDelimiter(nextChr, buf, pos + 1); // Escape a quote\n              // Treat next char as a regular character\n              // TODO: need to compare bytes instead of single char\n\n              if (escape !== null && chr === escape && nextChr === quote) {\n                pos++;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                continue;\n              } else if (relax === false) {\n                var err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', \"got \\\"\".concat(String.fromCharCode(nextChr), \"\\\"\"), \"at line \".concat(this.info.lines), 'instead of delimiter, row delimiter, trimable character', '(if activated) or comment'], this.__context()));\n\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true; // continue\n\n                this.state.field.prepend(quote);\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax mode, treat opening quote preceded by chrs as regular\n                if (relax === false) {\n                  var _err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', \"a quote is found inside a field at line \".concat(this.info.lines)], this.__context(), {\n                    field: this.state.field\n                  }));\n\n                  if (_err !== undefined) return _err;\n                }\n              } else {\n                this.state.quoting = true;\n                continue;\n              }\n            }\n          }\n\n          if (this.state.quoting === false) {\n            var recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              var skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n              if (skipCommentLine) {\n                this.info.comment_lines++; // Skip full comment line\n              } else {\n                // Skip if line is empty and skip_empty_lines activated\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } // Activate records emition if above from_line\n\n\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n\n                  this.__resetField();\n\n                  this.__resetRow();\n\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } else {\n                  var errField = this.__onField();\n\n                  if (errField !== undefined) return errField;\n\n                  var errRecord = this.__onRow();\n\n                  if (errRecord !== undefined) return errRecord;\n                }\n\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  this.push(null);\n                  return;\n                }\n              }\n\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n\n            if (this.state.commenting) {\n              continue;\n            }\n\n            var commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n\n            var delimiterLength = this.__isDelimiter(chr, buf, pos);\n\n            if (delimiterLength !== 0) {\n              var _errField = this.__onField();\n\n              if (_errField !== undefined) return _errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            var _err2 = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', \"of \".concat(max_record_size), \"at line \".concat(this.info.lines)], this.__context()));\n\n            if (_err2 !== undefined) return _err2;\n          }\n        }\n\n        var lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField\n\n        var rappend = rtrim === false || this.state.wasQuoting === false;\n\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n          var _err3 = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', \"at line \".concat(this.info.lines)], this.__context()));\n\n          if (_err3 !== undefined) return _err3;\n        }\n      }\n\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          var _err4 = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', \"the parsing is finished with an opening quote at line \".concat(this.info.lines)], this.__context()));\n\n          if (_err4 !== undefined) return _err4;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            var _errField2 = this.__onField();\n\n            if (_errField2 !== undefined) return _errField2;\n\n            var _errRecord = this.__onRow();\n\n            if (_errRecord !== undefined) return _errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.previousBuf = buf.slice(pos);\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    } // Helper to test if a character is a space or a line delimiter\n\n  }, {\n    key: \"__isCharTrimable\",\n    value: function __isCharTrimable(chr) {\n      return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n    }\n  }, {\n    key: \"__onRow\",\n    value: function __onRow() {\n      var _this$options2 = this.options,\n          columns = _this$options2.columns,\n          columns_duplicates_to_array = _this$options2.columns_duplicates_to_array,\n          info = _this$options2.info,\n          from = _this$options2.from,\n          relax_column_count = _this$options2.relax_column_count,\n          relax_column_count_less = _this$options2.relax_column_count_less,\n          relax_column_count_more = _this$options2.relax_column_count_more,\n          raw = _this$options2.raw,\n          skip_lines_with_empty_values = _this$options2.skip_lines_with_empty_values;\n      var _this$state2 = this.state,\n          enabled = _this$state2.enabled,\n          record = _this$state2.record;\n\n      if (enabled === false) {\n        return this.__resetRow();\n      } // Convert the first line into column names\n\n\n      var recordLength = record.length;\n\n      if (columns === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRow();\n\n          return;\n        }\n\n        return this.__firstLineToColumns(record);\n      }\n\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n\n      if (recordLength !== this.state.expectedRecordLength) {\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n        } else {\n          if (columns === false) {\n            var err = this.__error(new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', \"expect \".concat(this.state.expectedRecordLength, \",\"), \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.__context(), {\n              record: record\n            }));\n\n            if (err !== undefined) return err;\n          } else {\n            var _err5 = this.__error( // CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS\n            new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', \"columns length is \".concat(columns.length, \",\"), // rename columns\n            \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.__context(), {\n              record: record\n            }));\n\n            if (_err5 !== undefined) return _err5;\n          }\n        }\n      }\n\n      if (skip_lines_with_empty_values === true) {\n        if (isRecordEmpty(record)) {\n          this.__resetRow();\n\n          return;\n        }\n      }\n\n      if (this.state.recordHasError === true) {\n        this.__resetRow();\n\n        this.state.recordHasError = false;\n        return;\n      }\n\n      this.info.records++;\n\n      if (from === 1 || this.info.records >= from) {\n        if (columns !== false) {\n          var obj = {}; // Transform record array to an object\n\n          for (var i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue; // obj[columns[i].name] = record[i]\n            // Turn duplicate columns into an array\n\n            if (columns_duplicates_to_array === true && obj[columns[i].name]) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n\n          var objname = this.options.objname;\n\n          if (objname === undefined) {\n            if (raw === true || info === true) {\n              var _err6 = this.__push(Object.assign({\n                record: obj\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString()\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err6) {\n                return _err6;\n              }\n            } else {\n              var _err7 = this.__push(obj);\n\n              if (_err7) {\n                return _err7;\n              }\n            }\n          } else {\n            if (raw === true || info === true) {\n              var _err8 = this.__push(Object.assign({\n                record: [obj[objname], obj]\n              }, raw === true ? {\n                raw: this.state.rawBuffer.toString()\n              } : {}, info === true ? {\n                info: this.state.info\n              } : {}));\n\n              if (_err8) {\n                return _err8;\n              }\n            } else {\n              var _err9 = this.__push([obj[objname], obj]);\n\n              if (_err9) {\n                return _err9;\n              }\n            }\n          }\n        } else {\n          if (raw === true || info === true) {\n            var _err10 = this.__push(Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString()\n            } : {}, info === true ? {\n              info: this.state.info\n            } : {}));\n\n            if (_err10) {\n              return _err10;\n            }\n          } else {\n            var _err11 = this.__push(record);\n\n            if (_err11) {\n              return _err11;\n            }\n          }\n        }\n      }\n\n      this.__resetRow();\n    }\n  }, {\n    key: \"__firstLineToColumns\",\n    value: function __firstLineToColumns(record) {\n      var firstLineToHeaders = this.state.firstLineToHeaders;\n\n      try {\n        var headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', \"got \".concat(JSON.stringify(headers))], this.__context(), {\n            headers: headers\n          }));\n        }\n\n        var normalizedHeaders = normalizeColumnsArray(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n\n        this.__resetRow();\n\n        return;\n      } catch (err) {\n        return err;\n      }\n    }\n  }, {\n    key: \"__resetRow\",\n    value: function __resetRow() {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n\n      this.state.record = [];\n      this.state.record_length = 0;\n    }\n  }, {\n    key: \"__onField\",\n    value: function __onField() {\n      var _this$options3 = this.options,\n          cast = _this$options3.cast,\n          rtrim = _this$options3.rtrim,\n          max_record_size = _this$options3.max_record_size;\n      var _this$state3 = this.state,\n          enabled = _this$state3.enabled,\n          wasQuoting = _this$state3.wasQuoting; // Short circuit for the from_line options\n\n      if (enabled === false) {\n        /* this.options.columns !== true && */\n        return this.__resetField();\n      }\n\n      var field = this.state.field.toString();\n\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n\n      if (cast === true) {\n        var _this$__cast = this.__cast(field),\n            _this$__cast2 = _slicedToArray(_this$__cast, 2),\n            err = _this$__cast2[0],\n            f = _this$__cast2[1];\n\n        if (err !== undefined) return err;\n        field = f;\n      }\n\n      this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n\n      this.__resetField();\n    }\n  }, {\n    key: \"__resetField\",\n    value: function __resetField() {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    }\n  }, {\n    key: \"__push\",\n    value: function __push(record) {\n      var on_record = this.options.on_record;\n\n      if (on_record !== undefined) {\n        var context = this.__context();\n\n        try {\n          record = on_record.call(null, record, context);\n        } catch (err) {\n          return err;\n        }\n\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n\n      this.push(record);\n    } // Return a tuple with the error and the casted value\n\n  }, {\n    key: \"__cast\",\n    value: function __cast(field) {\n      var _this$options4 = this.options,\n          columns = _this$options4.columns,\n          relax_column_count = _this$options4.relax_column_count;\n      var isColumns = Array.isArray(columns); // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n\n      var context = this.__context();\n\n      if (this.state.castField !== null) {\n        try {\n          return [undefined, this.state.castField.call(null, field, context)];\n        } catch (err) {\n          return [err];\n        }\n      }\n\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        return [undefined, this.options.cast_date.call(null, field, context)];\n      }\n\n      return [undefined, field];\n    } // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n\n  }, {\n    key: \"__isFloat\",\n    value: function __isFloat(value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    }\n  }, {\n    key: \"__compareBytes\",\n    value: function __compareBytes(sourceBuf, targetBuf, pos, firtByte) {\n      if (sourceBuf[0] !== firtByte) return 0;\n      var sourceLength = sourceBuf.length;\n\n      for (var i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[pos + i]) return 0;\n      }\n\n      return sourceLength;\n    }\n  }, {\n    key: \"__needMoreData\",\n    value: function __needMoreData(i, bufLen, end) {\n      if (end) {\n        return false;\n      }\n\n      var _this$options5 = this.options,\n          comment = _this$options5.comment,\n          delimiter = _this$options5.delimiter;\n      var _this$state4 = this.state,\n          quoting = _this$state4.quoting,\n          recordDelimiterMaxLength = _this$state4.recordDelimiterMaxLength;\n      var numOfCharLeft = bufLen - i - 1;\n      var requiredLength = Math.max( // Skip if the remaining buffer smaller than comment\n      comment ? comment.length : 0, // Skip if the remaining buffer smaller than row delimiter\n      recordDelimiterMaxLength, // Skip if the remaining buffer can be row delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? 1 + recordDelimiterMaxLength : 0, // Skip if the remaining buffer can be delimiter\n      delimiter.length, // Skip if the remaining buffer can be escape sequence\n      // 1 is for escape.length\n      1);\n      return numOfCharLeft < requiredLength;\n    }\n  }, {\n    key: \"__isDelimiter\",\n    value: function __isDelimiter(chr, buf, pos) {\n      var delimiter = this.options.delimiter;\n\n      loop1: for (var i = 0; i < delimiter.length; i++) {\n        var del = delimiter[i];\n\n        if (del[0] === chr) {\n          for (var j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return del.length;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__isRecordDelimiter\",\n    value: function __isRecordDelimiter(chr, buf, pos) {\n      var record_delimiter = this.options.record_delimiter;\n      var recordDelimiterLength = record_delimiter.length;\n\n      loop1: for (var i = 0; i < recordDelimiterLength; i++) {\n        var rd = record_delimiter[i];\n        var rdLength = rd.length;\n\n        if (rd[0] !== chr) {\n          continue;\n        }\n\n        for (var j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n\n        return rd.length;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__autoDiscoverRowDelimiter\",\n    value: function __autoDiscoverRowDelimiter(buf, pos) {\n      var chr = buf[pos];\n\n      if (chr === cr) {\n        if (buf[pos + 1] === nl) {\n          this.options.record_delimiter.push(Buffer.from('\\r\\n'));\n          this.state.recordDelimiterMaxLength = 2;\n          return 2;\n        } else {\n          this.options.record_delimiter.push(Buffer.from('\\r'));\n          this.state.recordDelimiterMaxLength = 1;\n          return 1;\n        }\n      } else if (chr === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\n'));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__error\",\n    value: function __error(msg) {\n      var skip_lines_with_error = this.options.skip_lines_with_error;\n      var err = typeof msg === 'string' ? new Error(msg) : msg;\n\n      if (skip_lines_with_error) {\n        this.state.recordHasError = true;\n        this.emit('skip', err);\n        return undefined;\n      } else {\n        return err;\n      }\n    }\n  }, {\n    key: \"__context\",\n    value: function __context() {\n      var columns = this.options.columns;\n      var isColumns = Array.isArray(columns);\n      return {\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        empty_lines: this.info.empty_lines,\n        header: columns === true,\n        index: this.state.record.length,\n        invalid_field_length: this.info.invalid_field_length,\n        quoting: this.state.wasQuoting,\n        lines: this.info.lines,\n        records: this.info.records\n      };\n    }\n  }]);\n\n  return Parser;\n}(Transform);\n\nvar parse = function parse() {\n  var data, options, callback;\n\n  for (var i in arguments) {\n    var argument = arguments[i];\n\n    var type = _typeof(argument);\n\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(i)]);\n    }\n  }\n\n  var parser = new Parser(options);\n\n  if (callback) {\n    var records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      var record;\n\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.info);\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.info);\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n\n  return parser;\n};\n\nvar CsvError = /*#__PURE__*/function (_Error) {\n  _inherits(CsvError, _Error);\n\n  var _super2 = _createSuper(CsvError);\n\n  function CsvError(code, message) {\n    var _this2;\n\n    _classCallCheck(this, CsvError);\n\n    if (Array.isArray(message)) message = message.join(' ');\n    _this2 = _super2.call(this, message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_this2), CsvError);\n    }\n\n    _this2.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      contexts[_key - 2] = arguments[_key];\n    }\n\n    for (var _i2 = 0, _contexts = contexts; _i2 < _contexts.length; _i2++) {\n      var context = _contexts[_i2];\n\n      for (var key in context) {\n        var value = context[key];\n        _this2[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n\n    return _this2;\n  }\n\n  return CsvError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\n\nvar underscore = function underscore(str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nvar isObject = function isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar isRecordEmpty = function isRecordEmpty(record) {\n  return record.every(function (field) {\n    return field == null || field.toString && field.toString().trim() === '';\n  });\n};\n\nvar normalizeColumnsArray = function normalizeColumnsArray(columns) {\n  var normalizedColumns = [];\n\n  for (var i = 0, l = columns.length; i < l; i++) {\n    var column = columns[i];\n\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', \"property \\\"name\\\" is required at position \".concat(i), 'when column is an object literal']);\n      }\n\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', \"got \".concat(JSON.stringify(column), \" at position \").concat(i)]);\n    }\n  }\n\n  return normalizedColumns;\n};"]},"metadata":{},"sourceType":"script"}