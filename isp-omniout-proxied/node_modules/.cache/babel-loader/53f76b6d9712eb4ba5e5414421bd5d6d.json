{"ast":null,"code":"/**\n * @file Represents stream that handles Salesforce record as stream data\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n'use strict';\n\nvar events = require('events'),\n    stream = require('readable-stream'),\n    Duplex = stream.Duplex,\n    Transform = stream.Transform,\n    PassThrough = stream.PassThrough,\n    inherits = require('inherits'),\n    _ = require('lodash/core'),\n    CSV = require('./csv');\n/**\n * Class for Record Stream\n *\n * @class\n * @constructor\n * @extends stream.Transform\n */\n\n\nvar RecordStream = module.exports = function () {\n  RecordStream.super_.call(this, {\n    objectMode: true\n  });\n};\n\ninherits(RecordStream, Transform);\n/*\n * @override\n */\n\nRecordStream.prototype._transform = function (record, enc, callback) {\n  this.emit('record', record);\n  this.push(record);\n  callback();\n};\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream}\n */\n\n\nRecordStream.prototype.map = function (fn) {\n  return this.pipe(RecordStream.map(fn));\n};\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream}\n */\n\n\nRecordStream.prototype.filter = function (fn) {\n  return this.pipe(RecordStream.filter(fn));\n};\n/**\n * @class RecordStream.Serializable\n * @extends {RecordStream}\n */\n\n\nvar Serializable = RecordStream.Serializable = function () {\n  Serializable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Serializable, RecordStream);\n/**\n * Create readable data stream which emits serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\n\nSerializable.prototype.stream = function (type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this.pipe(converter.serialize(options)).pipe(this._dataStream);\n  }\n\n  return this._dataStream;\n};\n/**\n * @class RecordStream.Parsable\n * @extends {RecordStream}\n */\n\n\nvar Parsable = RecordStream.Parsable = function () {\n  Parsable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Parsable, RecordStream);\n/**\n * Create writable data stream which accepts serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\n\nParsable.prototype.stream = function (type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  var self = this;\n\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this._parserStream = converter.parse(options).on('error', function (error) {\n      self.emit('error', error);\n    });\n\n    this._parserStream.pipe(this).pipe(new PassThrough({\n      objectMode: true,\n      highWaterMark: 500 * 1000\n    }));\n  }\n\n  return this._dataStream;\n};\n/* @override */\n\n\nParsable.prototype.on = function (ev, fn) {\n  if (ev === 'readable' || ev === 'record') {\n    this._dataStream.pipe(this._parserStream);\n  }\n\n  return Parsable.super_.prototype.on.call(this, ev, fn);\n};\n/* @override */\n\n\nParsable.prototype.addListener = Parsable.prototype.on;\n/* --------------------------------------------------- */\n\n/**\n * @callback RecordMapFunction\n * @param {Record} record - Source record to map\n * @returns {Record}\n */\n\n/**\n * Create a record stream which maps records and pass them to downstream\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\n\nRecordStream.map = function (fn) {\n  var mapStream = new RecordStream.Serializable();\n\n  mapStream._transform = function (record, enc, callback) {\n    var rec = fn(record) || record; // if not returned record, use same record\n\n    this.push(rec);\n    callback();\n  };\n\n  return mapStream;\n};\n/**\n * Create mapping stream using given record template\n *\n * @param {Record} record - Mapping record object. In mapping field value, temlate notation can be used to refer field value in source record, if noeval param is not true.\n * @param {Boolean} [noeval] - Disable template evaluation in mapping record.\n * @returns {RecordStream.Serializable}\n */\n\n\nRecordStream.recordMapStream = function (record, noeval) {\n  return RecordStream.map(function (rec) {\n    var mapped = {\n      Id: rec.Id\n    };\n\n    for (var prop in record) {\n      mapped[prop] = noeval ? record[prop] : evalMapping(record[prop], rec);\n    }\n\n    return mapped;\n  });\n\n  function evalMapping(value, mapping) {\n    if (_.isString(value)) {\n      var m = /^\\$\\{(\\w+)\\}$/.exec(value);\n\n      if (m) {\n        return mapping[m[1]];\n      }\n\n      return value.replace(/\\$\\{(\\w+)\\}/g, function ($0, prop) {\n        var v = mapping[prop];\n        return _.isNull(v) || _.isUndefined(v) ? \"\" : String(v);\n      });\n    } else {\n      return value;\n    }\n  }\n};\n/**\n * @callback RecordFilterFunction\n * @param {Record} record - Source record to filter\n * @returns {Boolean}\n */\n\n/**\n * Create a record stream which filters records and pass them to downstream\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\n\n\nRecordStream.filter = function (fn) {\n  var filterStream = new RecordStream.Serializable();\n\n  filterStream._transform = function (record, enc, callback) {\n    if (fn(record)) {\n      this.push(record);\n    }\n\n    callback();\n  };\n\n  return filterStream;\n};\n/**\n * @private\n */\n\n\nfunction convertRecordForSerialization(record, options) {\n  return Object.keys(record).reduce(function (rec, key) {\n    var value = rec[key];\n    var t = typeof value;\n    var urec = {};\n\n    if (key === 'attributes') {\n      // 'attributes' prop will be ignored\n      rec = _.extend({}, rec);\n      delete rec[key];\n    } else if (options.nullValue && value === null) {\n      urec[key] = options.nullValue;\n      rec = _.extend({}, rec, urec);\n    } else if (value !== null && typeof value === 'object') {\n      var precord = convertRecordForSerialization(value, options);\n      rec = Object.keys(precord).reduce(function (prec, pkey) {\n        prec[key + '.' + pkey] = precord[pkey];\n        return prec;\n      }, _.extend({}, rec));\n    }\n\n    return rec;\n  }, record);\n}\n/**\n * @private\n */\n\n\nfunction createPipelineStream(s1, s2) {\n  var pipeline = new PassThrough();\n  pipeline.on('pipe', function (source) {\n    source.unpipe(pipeline);\n    source.pipe(s1).pipe(s2);\n  });\n\n  pipeline.pipe = function (dest, options) {\n    return s2.pipe(dest, options);\n  };\n\n  return pipeline;\n}\n/** ---------------------------------------------------------------------- **/\n\n/**\n * @private\n */\n\n\nvar CSVStreamConverter = {\n  serialize: function (options) {\n    options = options || {};\n    return createPipelineStream(RecordStream.map(function (record) {\n      return convertRecordForSerialization(record, options);\n    }), CSV.serializeCSVStream(options));\n  },\n  parse: function (options) {\n    return CSV.parseCSVStream(options);\n  }\n};\n/**\n * @private\n */\n\nvar DataStreamConverters = RecordStream.DataStreamConverters = {\n  csv: CSVStreamConverter\n};","map":{"version":3,"sources":["/Users/gcarminati/Desktop/OmniStudio/OmniProxy/react-express-proxy-sample/node_modules/jsforce/lib/record-stream.js"],"names":["events","require","stream","Duplex","Transform","PassThrough","inherits","_","CSV","RecordStream","module","exports","super_","call","objectMode","prototype","_transform","record","enc","callback","emit","push","map","fn","pipe","filter","Serializable","_dataStream","type","options","converter","DataStreamConverters","Error","serialize","Parsable","self","_parserStream","parse","on","error","highWaterMark","ev","addListener","mapStream","rec","recordMapStream","noeval","mapped","Id","prop","evalMapping","value","mapping","isString","m","exec","replace","$0","v","isNull","isUndefined","String","filterStream","convertRecordForSerialization","Object","keys","reduce","key","t","urec","extend","nullValue","precord","prec","pkey","createPipelineStream","s1","s2","pipeline","source","unpipe","dest","CSVStreamConverter","serializeCSVStream","parseCSVStream","csv"],"mappings":"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","sourcesContent":["/**\n * @file Represents stream that handles Salesforce record as stream data\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar events = require('events'),\n    stream = require('readable-stream'),\n    Duplex = stream.Duplex,\n    Transform = stream.Transform,\n    PassThrough = stream.PassThrough,\n    inherits = require('inherits'),\n    _      = require('lodash/core'),\n    CSV    = require('./csv');\n\n\n/**\n * Class for Record Stream\n *\n * @class\n * @constructor\n * @extends stream.Transform\n */\nvar RecordStream = module.exports = function() {\n  RecordStream.super_.call(this, { objectMode: true });\n};\n\ninherits(RecordStream, Transform);\n\n\n/*\n * @override\n */\nRecordStream.prototype._transform = function(record, enc, callback) {\n  this.emit('record', record);\n  this.push(record);\n  callback();\n};\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream}\n */\nRecordStream.prototype.map = function(fn) {\n  return this.pipe(RecordStream.map(fn));\n};\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream}\n */\nRecordStream.prototype.filter = function(fn) {\n  return this.pipe(RecordStream.filter(fn));\n};\n\n\n/**\n * @class RecordStream.Serializable\n * @extends {RecordStream}\n */\nvar Serializable = RecordStream.Serializable = function() {\n  Serializable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Serializable, RecordStream);\n\n/**\n * Create readable data stream which emits serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nSerializable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this.pipe(converter.serialize(options))\n      .pipe(this._dataStream);\n  }\n  return this._dataStream;\n};\n\n\n/**\n * @class RecordStream.Parsable\n * @extends {RecordStream}\n */\nvar Parsable = RecordStream.Parsable = function() {\n  Parsable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Parsable, RecordStream);\n\n/**\n * Create writable data stream which accepts serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nParsable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  var self = this;\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this._parserStream = converter.parse(options).on('error', function(error) { self.emit('error', error); });\n    this._parserStream.pipe(this).pipe(new PassThrough({ objectMode: true, highWaterMark: ( 500 * 1000 ) }));\n  }\n  return this._dataStream;\n};\n\n\n/* @override */\nParsable.prototype.on = function(ev, fn) {\n  if (ev === 'readable' || ev === 'record') {\n    this._dataStream.pipe(this._parserStream);\n  }\n  return Parsable.super_.prototype.on.call(this, ev, fn);\n};\n\n/* @override */\nParsable.prototype.addListener = Parsable.prototype.on;\n\n/* --------------------------------------------------- */\n\n/**\n * @callback RecordMapFunction\n * @param {Record} record - Source record to map\n * @returns {Record}\n */\n\n/**\n * Create a record stream which maps records and pass them to downstream\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.map = function(fn) {\n  var mapStream = new RecordStream.Serializable();\n  mapStream._transform = function(record, enc, callback) {\n    var rec = fn(record) || record; // if not returned record, use same record\n    this.push(rec);\n    callback();\n  };\n  return mapStream;\n};\n\n/**\n * Create mapping stream using given record template\n *\n * @param {Record} record - Mapping record object. In mapping field value, temlate notation can be used to refer field value in source record, if noeval param is not true.\n * @param {Boolean} [noeval] - Disable template evaluation in mapping record.\n * @returns {RecordStream.Serializable}\n */\nRecordStream.recordMapStream = function(record, noeval) {\n  return RecordStream.map(function(rec) {\n    var mapped = { Id: rec.Id };\n    for (var prop in record) {\n      mapped[prop] = noeval ? record[prop] : evalMapping(record[prop], rec);\n    }\n    return mapped;\n  });\n\n  function evalMapping(value, mapping) {\n    if (_.isString(value)) {\n      var m = /^\\$\\{(\\w+)\\}$/.exec(value);\n      if (m) { return mapping[m[1]]; }\n      return value.replace(/\\$\\{(\\w+)\\}/g, function($0, prop) {\n        var v = mapping[prop];\n        return _.isNull(v) || _.isUndefined(v) ? \"\" : String(v);\n      });\n    } else {\n      return value;\n    }\n  }\n};\n\n/**\n * @callback RecordFilterFunction\n * @param {Record} record - Source record to filter\n * @returns {Boolean}\n */\n\n/**\n * Create a record stream which filters records and pass them to downstream\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.filter = function(fn) {\n  var filterStream = new RecordStream.Serializable();\n  filterStream._transform = function(record, enc, callback) {\n    if (fn(record)) { this.push(record); }\n    callback();\n  };\n  return filterStream;\n};\n\n/**\n * @private\n */\nfunction convertRecordForSerialization(record, options) {\n  return Object.keys(record).reduce(function(rec, key) {\n    var value = rec[key];\n    var t = typeof value;\n    var urec = {};\n    if (key === 'attributes') { // 'attributes' prop will be ignored\n      rec = _.extend({}, rec);\n      delete rec[key];\n    } else if (options.nullValue && value === null) {\n      urec[key] = options.nullValue;\n      rec = _.extend({}, rec, urec);\n    } else if (value !== null && typeof value === 'object') {\n      var precord = convertRecordForSerialization(value, options);\n      rec = Object.keys(precord).reduce(function(prec, pkey) {\n        prec[key + '.' + pkey] = precord[pkey];\n        return prec;\n      }, _.extend({}, rec));\n    }\n    return rec;\n  }, record);\n}\n\n/**\n * @private\n */\nfunction createPipelineStream(s1, s2) {\n  var pipeline = new PassThrough();\n  pipeline.on('pipe', function(source) {\n    source.unpipe(pipeline);\n    source.pipe(s1).pipe(s2);\n  });\n  pipeline.pipe = function(dest, options) {\n    return s2.pipe(dest, options);\n  };\n  return pipeline;\n}\n\n/** ---------------------------------------------------------------------- **/\n\n/**\n * @private\n */\nvar CSVStreamConverter = {\n  serialize: function(options) {\n    options = options || {};\n    return createPipelineStream(\n      RecordStream.map(function(record) {\n        return convertRecordForSerialization(record, options);\n      }),\n      CSV.serializeCSVStream(options)\n    );\n  },\n  parse: function(options) {\n    return CSV.parseCSVStream(options);\n  }\n};\n\n/**\n * @private\n */\nvar DataStreamConverters = RecordStream.DataStreamConverters = {\n  csv: CSVStreamConverter\n};\n"]},"metadata":{},"sourceType":"script"}