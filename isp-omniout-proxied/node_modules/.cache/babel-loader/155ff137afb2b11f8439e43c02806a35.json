{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits'),\n    events = require('events'),\n    _ = require('lodash/core'),\n    Promise = require('./promise');\n/**\n * HTTP based API class with authorization hook\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n * @param {Object} [options] - Http API Options\n * @param {String} [options.responseType] - Overriding content mime-type in response\n * @param {Transport} [options.transport] - Transport for http api\n * @param {Object} [options.noContentResponse] - Alternative response when no content returned in response (= HTTP 204)\n */\n\n\nvar HttpApi = function (conn, options) {\n  options = options || {};\n  this._conn = conn;\n  this.on('resume', function (err) {\n    conn.emit('resume', err);\n  });\n  this._responseType = options.responseType;\n  this._transport = options.transport || conn._transport;\n  this._noContentResponse = options.noContentResponse;\n};\n\ninherits(HttpApi, events.EventEmitter);\n/**\n * Callout to API endpoint using http\n *\n * @param {Object} request - Http Request object\n * @param {String} request.url - Endpoint URL to request\n * @param {String} request.method - Http method for request\n * @param {Object} [request.headers] - Http request headers in hash object\n * @param {Callback.<Object>} callback - Callback function\n * @returns {Promise.<Object>} -\n */\n\nHttpApi.prototype.request = function (request, callback) {\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  var refreshDelegate = this.getRefreshDelegate(); // remember previous instance url in case it changes after a refresh\n\n  var lastInstanceUrl = conn.instanceUrl;\n  var deferred = Promise.defer();\n\n  var onResume = function (err) {\n    if (err) {\n      deferred.reject(err);\n      return;\n    } // check to see if the token refresh has changed the instance url\n\n\n    if (lastInstanceUrl !== conn.instanceUrl) {\n      // if the instance url has changed\n      // then replace the current request urls instance url fragment\n      // with the updated instance url\n      request.url = request.url.replace(lastInstanceUrl, conn.instanceUrl);\n    }\n\n    self.request(request).then(function (response) {\n      deferred.resolve(response);\n    }, function (err) {\n      deferred.reject(err);\n    });\n  };\n\n  if (refreshDelegate && refreshDelegate._refreshing) {\n    refreshDelegate.once('resume', onResume);\n    return deferred.promise.thenCall(callback);\n  } // hook before sending\n\n\n  self.beforeSend(request);\n  self.emit('request', request);\n  logger.debug(\"<request> method=\" + request.method + \", url=\" + request.url);\n  var requestTime = Date.now();\n  return this._transport.httpRequest(request).then(function (response) {\n    var responseTime = Date.now();\n    logger.debug(\"elappsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.debug(\"<response> status=\" + response.statusCode + \", url=\" + request.url);\n    self.emit('response', response); // Refresh token if session has been expired and requires authentication\n    // when session refresh delegate is available\n\n    if (self.isSessionExpired(response) && refreshDelegate) {\n      refreshDelegate.refresh(requestTime, onResume);\n      return deferred.promise;\n    }\n\n    if (self.isErrorResponse(response)) {\n      var err = self.getError(response);\n      throw err;\n    }\n\n    return self.getResponseBody(response);\n  }, function (err) {\n    var responseTime = Date.now();\n    logger.debug(\"elappsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.error(err);\n    throw err;\n  }).thenCall(callback);\n};\n/**\n * @protected\n */\n\n\nHttpApi.prototype.getRefreshDelegate = function () {\n  return this._conn._refreshDelegate;\n};\n/**\n *\n * @protected\n */\n\n\nHttpApi.prototype.beforeSend = function (request) {\n  request.headers = request.headers || {};\n\n  if (this._conn.accessToken) {\n    request.headers.Authorization = \"Bearer \" + this._conn.accessToken;\n  }\n\n  if (this._conn.callOptions) {\n    var callOptions = [];\n\n    for (var name in this._conn.callOptions) {\n      callOptions.push(name + \"=\" + this._conn.callOptions[name]);\n    }\n\n    request.headers[\"Sforce-Call-Options\"] = callOptions.join(', ');\n  }\n};\n/**\n * Detect response content mime-type\n * @protected\n */\n\n\nHttpApi.prototype.getResponseContentType = function (response) {\n  return this._responseType || response.headers && response.headers[\"content-type\"];\n};\n/**\n *\n */\n\n\nHttpApi.prototype.parseResponseBody = function (response) {\n  var contentType = this.getResponseContentType(response);\n  var parseBody = /^(text|application)\\/xml(;|$)/.test(contentType) ? parseXML : /^application\\/json(;|$)/.test(contentType) ? parseJSON : /^text\\/csv(;|$)/.test(contentType) ? parseCSV : parseText;\n\n  try {\n    return parseBody(response.body);\n  } catch (e) {\n    return response.body;\n  }\n};\n/**\n * Get response body\n * @protected\n */\n\n\nHttpApi.prototype.getResponseBody = function (response) {\n  if (response.statusCode === 204) {\n    // No Content\n    return this._noContentResponse;\n  }\n\n  var body = this.parseResponseBody(response);\n  var err;\n\n  if (this.hasErrorInResponseBody(body)) {\n    err = this.getError(response, body);\n    throw err;\n  }\n\n  if (response.statusCode === 300) {\n    // Multiple Choices\n    err = new Error('Multiple records found');\n    err.name = \"MULTIPLE_CHOICES\";\n    err.content = body;\n    throw err;\n  }\n\n  return body;\n};\n/** @private */\n\n\nfunction parseJSON(str) {\n  return JSON.parse(str);\n}\n/** @private */\n\n\nfunction parseXML(str) {\n  var ret = {};\n\n  require('xml2js').parseString(str, {\n    explicitArray: false\n  }, function (err, result) {\n    ret = {\n      error: err,\n      result: result\n    };\n  });\n\n  if (ret.error) {\n    throw ret.error;\n  }\n\n  return ret.result;\n}\n/** @private */\n\n\nfunction parseCSV(str) {\n  return require('./csv').parseCSV(str);\n}\n/** @private */\n\n\nfunction parseText(str) {\n  return str;\n}\n/**\n * Detect session expiry\n * @protected\n */\n\n\nHttpApi.prototype.isSessionExpired = function (response) {\n  return response.statusCode === 401;\n};\n/**\n * Detect error response\n * @protected\n */\n\n\nHttpApi.prototype.isErrorResponse = function (response) {\n  return response.statusCode >= 400;\n};\n/**\n * Detect error in response body\n * @protected\n */\n\n\nHttpApi.prototype.hasErrorInResponseBody = function (body) {\n  return false;\n};\n/**\n * Parsing error message in response\n * @protected\n */\n\n\nHttpApi.prototype.parseError = function (body) {\n  var errors = body;\n  return _.isArray(errors) ? errors[0] : errors;\n};\n/**\n * Get error message in response\n * @protected\n */\n\n\nHttpApi.prototype.getError = function (response, body) {\n  var error;\n\n  try {\n    error = this.parseError(body || this.parseResponseBody(response));\n  } catch (e) {}\n\n  error = _.isObject(error) && _.isString(error.message) ? error : {\n    errorCode: 'ERROR_HTTP_' + response.statusCode,\n    message: response.body\n  };\n  var err = new Error(error.message);\n  err.name = error.errorCode;\n\n  for (var key in error) {\n    err[key] = error[key];\n  }\n\n  return err;\n};\n/*-------------------------------------------------------------------------*/\n\n/**\n * @protected\n */\n\n\nvar SessionRefreshDelegate = function (conn, refreshFn) {\n  this._conn = conn;\n  this._refreshFn = refreshFn;\n  this._refreshing = false;\n};\n\ninherits(SessionRefreshDelegate, events.EventEmitter);\n/**\n * Refresh access token\n * @private\n */\n\nSessionRefreshDelegate.prototype.refresh = function (since, callback) {\n  // Callback immediately When refreshed after designated time\n  if (this._lastRefreshedAt > since) {\n    return callback();\n  }\n\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  self.once('resume', callback);\n\n  if (self._refreshing) {\n    return;\n  }\n\n  logger.debug(\"<refresh token>\");\n  self._refreshing = true;\n  return self._refreshFn(conn, function (err, accessToken, res) {\n    if (!err) {\n      logger.debug(\"Connection refresh completed.\");\n      conn.accessToken = accessToken;\n      conn.emit(\"refresh\", accessToken, res);\n    }\n\n    self._lastRefreshedAt = Date.now();\n    self._refreshing = false;\n    self.emit('resume', err);\n  });\n};\n/**\n *\n */\n\n\nHttpApi.SessionRefreshDelegate = SessionRefreshDelegate;\nmodule.exports = HttpApi;","map":{"version":3,"sources":["/Users/gcarminati/Desktop/OmniStudio/OmniProxy/react-express-proxy-sample/node_modules/jsforce/lib/http-api.js"],"names":["inherits","require","events","_","Promise","HttpApi","conn","options","_conn","on","err","emit","_responseType","responseType","_transport","transport","_noContentResponse","noContentResponse","EventEmitter","prototype","request","callback","self","logger","_logger","refreshDelegate","getRefreshDelegate","lastInstanceUrl","instanceUrl","deferred","defer","onResume","reject","url","replace","then","response","resolve","_refreshing","once","promise","thenCall","beforeSend","debug","method","requestTime","Date","now","httpRequest","responseTime","statusCode","isSessionExpired","refresh","isErrorResponse","getError","getResponseBody","error","_refreshDelegate","headers","accessToken","Authorization","callOptions","name","push","join","getResponseContentType","parseResponseBody","contentType","parseBody","test","parseXML","parseJSON","parseCSV","parseText","body","e","hasErrorInResponseBody","Error","content","str","JSON","parse","ret","parseString","explicitArray","result","parseError","errors","isArray","isObject","isString","message","errorCode","key","SessionRefreshDelegate","refreshFn","_refreshFn","since","_lastRefreshedAt","res","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('inherits'),\n    events = require('events'),\n    _ = require('lodash/core'),\n    Promise = require('./promise');\n\n/**\n * HTTP based API class with authorization hook\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n * @param {Object} [options] - Http API Options\n * @param {String} [options.responseType] - Overriding content mime-type in response\n * @param {Transport} [options.transport] - Transport for http api\n * @param {Object} [options.noContentResponse] - Alternative response when no content returned in response (= HTTP 204)\n */\nvar HttpApi = function(conn, options) {\n  options = options || {};\n  this._conn = conn;\n  this.on('resume', function(err) { conn.emit('resume', err); });\n  this._responseType = options.responseType;\n  this._transport = options.transport || conn._transport;\n  this._noContentResponse = options.noContentResponse;\n};\n\ninherits(HttpApi, events.EventEmitter);\n\n/**\n * Callout to API endpoint using http\n *\n * @param {Object} request - Http Request object\n * @param {String} request.url - Endpoint URL to request\n * @param {String} request.method - Http method for request\n * @param {Object} [request.headers] - Http request headers in hash object\n * @param {Callback.<Object>} callback - Callback function\n * @returns {Promise.<Object>} -\n */\nHttpApi.prototype.request = function(request, callback) {\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  var refreshDelegate = this.getRefreshDelegate();\n  // remember previous instance url in case it changes after a refresh\n  var lastInstanceUrl = conn.instanceUrl;\n\n  var deferred = Promise.defer();\n\n  var onResume = function(err) {\n    if (err) {\n      deferred.reject(err);\n      return;\n    }\n    // check to see if the token refresh has changed the instance url\n    if(lastInstanceUrl !== conn.instanceUrl){\n      // if the instance url has changed\n      // then replace the current request urls instance url fragment\n      // with the updated instance url\n      request.url = request.url.replace(lastInstanceUrl,conn.instanceUrl);\n    }\n\n    self.request(request).then(function(response) {\n      deferred.resolve(response);\n    }, function(err) {\n      deferred.reject(err);\n    });\n  };\n\n  if (refreshDelegate && refreshDelegate._refreshing) {\n    refreshDelegate.once('resume', onResume);\n    return deferred.promise.thenCall(callback);\n  }\n\n  // hook before sending\n  self.beforeSend(request);\n\n  self.emit('request', request);\n  logger.debug(\"<request> method=\" + request.method + \", url=\" + request.url);\n  var requestTime = Date.now();\n\n  return this._transport.httpRequest(request).then(function(response) {\n    var responseTime = Date.now();\n    logger.debug(\"elappsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.debug(\"<response> status=\" + response.statusCode + \", url=\" + request.url);\n\n    self.emit('response', response);\n    // Refresh token if session has been expired and requires authentication\n    // when session refresh delegate is available\n    if (self.isSessionExpired(response) && refreshDelegate) {\n      refreshDelegate.refresh(requestTime, onResume);\n      return deferred.promise;\n    }\n    if (self.isErrorResponse(response)) {\n      var err = self.getError(response);\n      throw err;\n    }\n    return self.getResponseBody(response);\n  }, function(err) {\n    var responseTime = Date.now();\n    logger.debug(\"elappsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.error(err);\n    throw err;\n  })\n  .thenCall(callback);\n};\n\n/**\n * @protected\n */\nHttpApi.prototype.getRefreshDelegate = function() {\n  return this._conn._refreshDelegate;\n};\n\n/**\n *\n * @protected\n */\nHttpApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  if (this._conn.accessToken) {\n    request.headers.Authorization = \"Bearer \" + this._conn.accessToken;\n  }\n  if (this._conn.callOptions) {\n    var callOptions = [];\n    for (var name in this._conn.callOptions) {\n      callOptions.push(name + \"=\" + this._conn.callOptions[name]);\n    }\n    request.headers[\"Sforce-Call-Options\"] = callOptions.join(', ');\n  }\n};\n\n/**\n * Detect response content mime-type\n * @protected\n */\nHttpApi.prototype.getResponseContentType = function(response) {\n  return this._responseType || response.headers && response.headers[\"content-type\"];\n};\n\n/**\n *\n */\nHttpApi.prototype.parseResponseBody = function(response) {\n  var contentType = this.getResponseContentType(response);\n  var parseBody = /^(text|application)\\/xml(;|$)/.test(contentType) ? parseXML :\n         /^application\\/json(;|$)/.test(contentType) ? parseJSON :\n         /^text\\/csv(;|$)/.test(contentType) ? parseCSV :\n         parseText;\n  try {\n    return parseBody(response.body);\n  } catch(e) {\n    return response.body;\n  }\n};\n\n/**\n * Get response body\n * @protected\n */\nHttpApi.prototype.getResponseBody = function(response) {\n  if (response.statusCode === 204) { // No Content\n    return this._noContentResponse;\n  }\n  var body = this.parseResponseBody(response);\n  var err;\n  if (this.hasErrorInResponseBody(body)) {\n    err = this.getError(response, body);\n    throw err;\n  }\n  if (response.statusCode === 300) { // Multiple Choices\n    err = new Error('Multiple records found');\n    err.name = \"MULTIPLE_CHOICES\";\n    err.content = body;\n    throw err;\n  }\n  return body;\n};\n\n/** @private */\nfunction parseJSON(str) {\n  return JSON.parse(str);\n}\n\n/** @private */\nfunction parseXML(str) {\n  var ret = {};\n  require('xml2js').parseString(str, { explicitArray: false }, function(err, result) {\n    ret = { error: err, result : result };\n  });\n  if (ret.error) { throw ret.error; }\n  return ret.result;\n}\n\n/** @private */\nfunction parseCSV(str) {\n  return require('./csv').parseCSV(str);\n}\n\n/** @private */\nfunction parseText(str) { return str; }\n\n\n/**\n * Detect session expiry\n * @protected\n */\nHttpApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 401;\n};\n\n/**\n * Detect error response\n * @protected\n */\nHttpApi.prototype.isErrorResponse = function(response) {\n  return response.statusCode >= 400;\n};\n\n/**\n * Detect error in response body\n * @protected\n */\nHttpApi.prototype.hasErrorInResponseBody = function(body) {\n  return false;\n};\n\n/**\n * Parsing error message in response\n * @protected\n */\nHttpApi.prototype.parseError = function(body) {\n  var errors = body;\n  return _.isArray(errors) ? errors[0] : errors;\n};\n\n/**\n * Get error message in response\n * @protected\n */\nHttpApi.prototype.getError = function(response, body) {\n  var error;\n  try {\n    error = this.parseError(body || this.parseResponseBody(response));\n  } catch(e) {}\n  error = _.isObject(error) && _.isString(error.message) ? error : {\n    errorCode: 'ERROR_HTTP_' + response.statusCode,\n    message : response.body\n  };\n  var err = new Error(error.message);\n  err.name = error.errorCode;\n  for (var key in error) { err[key] = error[key]; }\n  return err;\n};\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * @protected\n */\nvar SessionRefreshDelegate = function(conn, refreshFn) {\n  this._conn = conn;\n  this._refreshFn = refreshFn;\n  this._refreshing = false;\n};\n\ninherits(SessionRefreshDelegate, events.EventEmitter);\n\n/**\n * Refresh access token\n * @private\n */\nSessionRefreshDelegate.prototype.refresh = function(since, callback) {\n  // Callback immediately When refreshed after designated time\n  if (this._lastRefreshedAt > since) { return callback(); }\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  self.once('resume', callback);\n  if (self._refreshing) { return; }\n  logger.debug(\"<refresh token>\");\n  self._refreshing = true;\n  return self._refreshFn(conn, function(err, accessToken, res) {\n    if (!err) {\n      logger.debug(\"Connection refresh completed.\");\n      conn.accessToken = accessToken;\n      conn.emit(\"refresh\", accessToken, res);\n    }\n    self._lastRefreshedAt = Date.now();\n    self._refreshing = false;\n    self.emit('resume', err);\n  });\n};\n\n\n/**\n *\n */\nHttpApi.SessionRefreshDelegate = SessionRefreshDelegate;\nmodule.exports = HttpApi;\n"]},"metadata":{},"sourceType":"script"}